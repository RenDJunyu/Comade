![image-20200710160126433](D:/Typora/resources/storepics/image-20200710160126433.png)

编译器将注释内容更换为一个空格

标识符不能以数字开头![image-20200710160253794](D:/Typora/resources/storepics/image-20200710160253794.png)

宏定义尽量大写，标识符尽量小写（可以用大写开头替换下划线	

预处理——编译器——连接器

C99可以声明和语句混搭

/**/不能嵌套，因为左会主动寻找第一个右，导致第二个右报错

格式串包含普通字符和转换说明，转换说明以%开头，跟在%后边的信息指定了把数值从内部形式(二进制)转换成打印形式(字符)的方法![image-20200710163935564](D:/Typora/resources/storepics/image-20200710163935564.png)

“由实现定义”的行为
		C标准故意对C语言的部分内容未加指定，并认为其细节可以由“实现”来具体定义，所谓实现是指程序在特定的平台上编译、链接和执行所需要的软件。

![image-20200711144300848](D:/Typora/resources/storepics/image-20200711144300848.png)

未定义的行为

​	根据C标准，当程序中出现未定义的行为时，后果是不可预料的，不同的编译器给出的编译结果可能是不同的

```c
#include<stdio.h>
int main (){
    switch (1)
    {   //break;
        printf("1");
        defualt:;
    }
}
```

```C
goto 标识符
标识符:语句//二者顺序不固定
```

```c
#include<ctype.h>
toupper将小写字母转换为大写字母
```

limits.h头文件可以检查类型范围

%u输出无符号数

常量后的类型标志，L/LL，U（顺序、大小不定，但只能是LL或ll）

C99规定没有后缀的
	十进制应该是int、long int、long long int中能够表示的最小类型
	八进制和十六进制的应该包括unsigned(有后缀会改变可能类型列表)

整数溢出中，有符号的溢出是未定义行为
	而无符号则是对2^n^取模，n是用于储存结果的位数

格式串中：d(有符号十进制),u(无符号十进制),o(八进制),x(十六进制),hd(short int)![image-20200712151635562](D:/Typora/resources/storepics/image-20200712151635562.png)

内存分配的顺序取决于编译器，可以参考编译原理

指定初始化式scalar initializer![image-20200713144034576](D:/Typora/resources/storepics/image-20200713144034576.png)

赋值的顺序便不是问题

程序开发过程中留下空函数体是有意义的，由于没有时间完成函数，所以为它预留下空间，以后可以回来编写它的函数体![image-20200713153610339](D:/Typora/resources/storepics/image-20200713153610339.png)

![image-20200713154752365](D:/Typora/resources/storepics/image-20200713154752365.png)

```c
void f(const int * const p){
	int j;
	*p=0;	/*** WRONG ***/
	p=&j;	/*** WRONG ***/
}//指针及其指向的对象都被保护了
```

```c
#include<stdio.h>
int main(){
    int a[10]={0};
    2[a]=2;
    printf("%d",a[2]);
}
/*
E:\ZJU\Cmade>test
2
*/
//因为i[a]=*(i+a)=*(a+i)=a[i]
```

八进制和十六进制的转义使用要小心
八进制的转义在3个数字胡或者第一次出现非八进制数字结束
十六进制不限制为3个数字，而是直到第一个非十六进制数字截至

```c
\xfc=ü,\xfcrich有6个ürich,\xfcber有两个,\xfcber=¾r
```

大部分编译器会拒绝接收后面那种字符串，因为十六进制的转义序列通常范围限制在\x0~\xff

**延续字符串字面量**

​	在第一行末尾使用\结尾，第二行从下一行的起始位置继续(破坏了程序的缩进结构)，否则就会出现多余内容

​	better：当两条或更多条字符串字面量相邻时(仅用空白字符分割)，编译器或将它们合并

```c
	printf("as you can see,\
	this is used like this");
//or
	printf("this one I think better%c"
		"how do you think%c",',','?');	
//这种方法可以避免无效写法
//如"\xfcber"->"\xfc""ber"
```

puts在写完字符串后，总会添加一个额外的换行符

gets不会在开始读字符串之前跳过空白字符(scanf会)

```c
strncpy(str1,str2,sizeof(str1));
```

###### 编译预处理指令

```c
#开头的是编译预处理指令
	它们不是C语言的成分，但是C语言程序离不开它们
	#define用来定义一个宏
```

```c
.c->.i->.o->.s
		.i即是将.c进行预处理后的文件，进行原始的文本替换
		gcc –save-temps进行查看中间文件
    	或者cpp name.c直接生成.i
```

```c
#define <name> <rename>
	注意没有结尾的分号，因为不是C的语句
	名字必须是一个单词(意即标识符)，值可以是各种东西
	在C语言的编译器开始编译之前，编译预处理程序(cpp)会把程序中的名字换成值
	完全的文本替换，同样会省去注释
```

```c
没有值的宏
	#define _DEBUG
		这类宏是用于条件编译的，后面有其他的编译预处理指令
		来检查这个宏是否已经被定义过了
```

```c
预定义的宏
_LINE_//源代码文件当前所在行的行号
_FILE_//源代码文件的文件名
_DATE_//编译时候的日期
_TIME_//编译时候的时间
_STDC_//当要求程序严格遵循ANSIC标准时该标识符被赋值为1
```

```c
像函数的宏
#define cube(x) ((x)*(x)*(x))
	宏可以带参数
带参数的宏的原则
	一切都要有括号
		整个值要括号
		参数出现的每个地方都要括号
	#define RADTODEG(x) ((x)*57.29578)
带参数的宏
    可以带多个参数
    	#define MIN(a,b) ((a)>(b)?(b):(a))
		也可以组合(嵌套)使用其他宏
    在大型程序中的代码中使用非常普遍
    可以非常复杂，如"产生"函数
    	在#和##这两个预算符的帮助下
    存在中西方文化差异
    部分宏会被inline函数替代
宏定义最好不要加分号    
```

```c
其他编译预处理指令
	条件编译
	error
```

```c
C语言的预处理主要有三个方面的内容
	Ⅰ.宏定义
	Ⅱ.文件引用(包含)
	Ⅲ.条件编译
预处理命令以符号"#"开头
在编译预处理阶段，预处理程序读取c源程序，对其中的预处理指令和特殊符号进行处理。
	或者说是扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。
	预处理过程先于编译器对源代码进行处理
```

```c
宏运算符
	#运算符
		出现在宏定义中的#运算符把跟在其后的参数转换成一个字符串。
			有时把这种用法的#称为字符串化运算符。例如：
			#define PRINT_INT(n) printf(#n "=%d",n)
		预处理后这里会出现两个连着的字符串，会被合并为一个
	##运算符
    	##运算符用于把参数连接到一起。预处理程序把出现在##两个的参数合并成一个符号。
    		看下面的例子：
			#define MYCASE(item,id) \
			case id: \
				item##_##id = id;\
			break
			switch(x) {
				MYCASE(widget,23);
			}
```

```c
宏中"#"和"##"的用法
一、一般用法
我们使用#把宏参数变为一个字符串,用##把两个宏参数贴合在一起.
用法:
#define STR(s)      #s
#define CONS(a,b)   int(a##e##b)
二、当宏参数是另一个宏的时候
需要注意的是凡宏定义里有用'#'或'##'的地方宏参数是不会再展开.

1, 非'#'和'##'的情况
#define TOW       (2)
#define MUL(a,b) (a*b)

printf("%d*%d=%d\n", TOW, TOW, MUL(TOW,TOW));
这行的宏会被展开为：
printf("%d*%d=%d\n", (2), (2), ((2)*(2)));
MUL里的参数TOW会被展开为(2).

2, 当有'#'或'##'的时候
#define A           (2)
#define STR(s)      #s
#define CONS(a,b)   int(a##e##b)

printf("int max: %s\n",   STR(INT_MAX));     // INT_MAX ＃i nclude<climits>
这行会被展开为：
printf("int max: %s\n", "INT_MAX");

printf("%s\n", CONS(A, A));                // compile error  
这一行则是：
printf("%s\n", int(AeA));

INT_MAX和A都不会再被展开, 然而解决这个问题的方法很简单. 加多一层中间转换宏.
加这层宏的用意是把所有宏的参数在这层里全部展开, 那么在转换宏里的那一个宏(_STR)就能得到正确的宏参数.

#define A            (2)
#define _STR(s)      #s
#define STR(s)       _STR(s)           // 转换宏
#define _CONS(a,b)   int(a##e##b)
#define CONS(a,b)    _CONS(a,b)        // 转换宏

printf("int max: %s\n", STR(INT_MAX));           // INT_MAX,int型的最大值，为一个变量 ＃i nclude<climits>
输出为: int max: 0x7fffffff
STR(INT_MAX) -->   _STR(0x7fffffff) 然后再转换成字符串；

printf("%d\n", CONS(A, A));
输出为：200
CONS(A, A)   -->   _CONS((2), (2))   --> int((2)e(2))

三、'#'和'##'的一些应用特例
1、合并匿名变量名
#define   ___ANONYMOUS1(type, var, line)   type   var##line
#define   __ANONYMOUS0(type, line)   ___ANONYMOUS1(type, _anonymous, line)
#define   ANONYMOUS(type)   __ANONYMOUS0(type, __LINE__)
例：ANONYMOUS(static int);   即: static int _anonymous70;   70表示该行行号；
第一层：ANONYMOUS(static int);   -->   __ANONYMOUS0(static int, __LINE__);
第二层：                         -->   ___ANONYMOUS1(static int, _anonymous, 70);
第三层：                         -->   static int   _anonymous70;
即每次只能解开当前层的宏，所以__LINE__在第二层才能被解开；

2、填充结构
#define   FILL(a)    {a, #a}

enum IDD{OPEN, CLOSE};
typedef struct MSG{
   IDD id;
   const char * msg;
}MSG;

MSG _msg[] = {FILL(OPEN), FILL(CLOSE)};
相当于：
MSG _msg[] = {{OPEN, "OPEN"},
               {CLOSE, "CLOSE"}};

3、记录文件名
#define   _GET_FILE_NAME(f)    #f
#define   GET_FILE_NAME(f)     _GET_FILE_NAME(f)
static char   FILE_NAME[] = GET_FILE_NAME(__FILE__);

4、得到一个数值类型所对应的字符串缓冲大小
#define   _TYPE_BUF_SIZE(type)   sizeof #type
#define   TYPE_BUF_SIZE(type)    _TYPE_BUF_SIZE(type)
char   buf[TYPE_BUF_SIZE(INT_MAX)];
      -->   char   buf[_TYPE_BUF_SIZE(0x7fffffff)];
      -->   char   buf[sizeof "0x7fffffff"];
这里相当于：
char   buf[11];

“#把宏参数变为一个字符串,用##把两个宏参数贴合在一起
```

```c
条件编译
	windows专有的宏_WIN32,Linux专有的宏__linux__
	#ifdef	#else	#endif
	调试版本
        int main()
        {
            #ifdef _DEBUG
                printf("正在使用Debug 模式编译程序... \n");
            #else
                printf("正在使用Release模式编译程序...\n");
            #endif
        }
	w4-3.c
        ●这样调试版本和发布版本就可以有不同的代码
        ●编译时加上选项 -D _DEBUG 就可以编译调试版本
	#if	#elif	#else	#endif
   	条件编译
		int main()
			#if _WIN32
				system("color 0c");
				printf("Win: C Programming\n");
			#elif __Linux__
				printf("\033 [22;31mLinux: C Programming\n\033 [22;30m");
			#else
				printf("C Programming\n");
			#endif
			return 0;
		}
        ●如果宏_WIN32的值非0，就保留第6、7行代码，删除第9、11行代码;
		如果宏linux的值非0，就保留第9行代码;如果所有的宏都为0，就保留第11行代码。

```

```c
注释大段代码
    vscode ctrl+字母键盘/,选中注释
	●当程序中有大段代码需要被临时注释掉，使用/* */或//
    注释都不太方便，尤其是当代码中原本就有注释时。
    原本有/**/注释时，会和后加的/**/冲突。
    再加上//注释可能使得代码存在多重//
	●可以用#if 0.. . #endif来注释这段代码
```

```c
#error
	产生编译错误
	#error ""
#pragma
	●设定编译器的状态或者是指示编译器完成一些特定的动作。
	●#pragma指令对每个编译器给出了一个方法，在保持与C和C++语言完全兼容的情况下，
		给出主机或操作系统专有的特征。
	●依据定义，编译指示是机器或操作系统专有的，且对于每个编译器都是不同的
	●因此尽量避免使用#pragma

```

```c
错误处理
	●程序运行过程中，不可避免会出现一些情况， 不是由于程序员的主观错误，而是运行时的
		客观情况，导致某些代码无法正常执行
	●如果要打开文件读取其中数据，可能的伪代码如下:
		打开文件
		获取文件大小
		申请内存空间
		读入文件数据
		关闭文件
	●这里的每一步都可能在运行时遇到问题
	●这些问题是可以预见的、- -定存在发生的可能的、不是-定会发生的
```

```c
返回特殊值
	●C标准库中的I0函数,均会通过返回的特殊值来表示函数执行过程中出了问题，如:
		。malloc返回NULL表示没有空间了
		。fopen返回NULL表示文件没有打开
		。open返回-1表示文件没有打开
		。printf 返回输出了多少个字符，如果少于预期就是错误
		。scanf返回给多少个变量做了赋值，如果少于预期就是错误
	●一个健壮的程序应该判断所有这些函数的返回值，包括malloc和printf
	●使用每一个库函数(包括第三方库)之前都应该检查函数的说明，看返回值的意义
	●如man scanf就可以看scanf的说明
```

```c
返回特殊值
	●设计自己的函数的时候，也可以用这个方式返回特殊值来告诉调用者在这个函数执行中出
		现了问题
	●当函数的返回值是全域的，就无法找到特殊值来表示错误，如:
		int divide(int a, int b) {
			return a/b;
		}
	如何处理b为0的情况?
```

```c
返回错误
	●函数返回值表示错误与否，用参数带回结果
		int divide(int a, int b, int* result){
			intret=1;
            if(b) {
            	*result = a/b;
            }
			else {
            	ret = 0;
            	return ret;
			}
		}
		int c=0;
        if ( divide(20,3,&c) ) {
        	printf("%d\n"，c);
        } else {...
```

```c
全局错误值
    ●通过全局变量(或静态全局变量)和配套的函数来表达错误
    ●C标准库中的errno是记录系统的最后一次的错误编码。 这个编码是一个int型的值，在
    	errno.h中定义
    ●当C标准库函数发生异常时，一般会将errno变量赋一 个整数值,不同的值表示不同的含
    	义，可以通过查看该值推测出错的原因
    ●查看错误编码errno是调试程序的一个重要方法

```

```c
查看错误信息文本
	●下面几种方法可以方便的得到错误信息:
	●void perror(const char *s)
		。perror()用来将上一个函数发生错误的原因输出到标准错误(stderr),
			参数s所指的字符串会先打印出,后面再加上错误原因字符串。
            此错误原因依照全局变量errno的值来决定要输出的字符串。
	●char *strerror(int errno)
		。将错误代码转换为字符串错误信息,可以将该字符串和其它的信息组合输出到用户界
			面例如
		fprintf(stderr,"error in CreateProcess %S，Process ID %d
		", strerror(errno), processID) 
```

```c
设计自己的全局错误变量
	●宜将全局错误变量封装为static全局变量，以禁止外部的直接访问
	●对外通过类似perror、strerror 、geterror 这样的函数来读取这个错误变量的值
```

```c
断言
    ●assert是一个宏，定义在<assert.h>中， 作用是如果它的值是0，则终止程序执行
    	。assert(expression);
    ●如果其值为假(即为0)，那么它先向stderr打印一条出错信息，然后通过调用abort()
    	来终止程序运行
    ●错误信息如下:
        "assertion \"%s\" failed: file \"%s\", line %d\n", \
        "expression",__FILE__，__LINE__);
```

```c
断言的用法
    ●断言是用来发现程序员的错误的
    ●断言用在函数入口处，检查函数的参数值是否在有效的范围内
        /**
            改变缓冲区大小，
            保持原信息内容不变，nNewSize<=0 表示清除缓冲区
            @param nNewSize 缓冲区新长度
            @return 缓冲区当前长度
        */
        int resetBufferSize(int nNewSize)
        {
            assert(nNewSize >= 0);
            assert(nNewSize <= MAX_ _BUFFER_ SIZE) ;
            ...
        }
	●如果调用resetBufferSize 的程序员给出了错误的nNewSize值，程序就会终止
```

```c
错误的断言
	●断言不应使用在判断程序运行状态的地方
		。如IO操作的结果
		。用户输入的数据有效性
	●每个断言只检验一个条件，因为同时检验多个条件时，如果断言失败，无法直观的判断是
		哪个条件失败，如: .
		assert(noffset>=0 && nOffset +nSize<=m_ nInfomationSize); 
			不好，应分成两个断言
	●断言的条件中不应做赋值，如:
		assert(i++ < 100); ，因为i++不一-定被执行
```

```c
程序的调试
    ●没有人能够保证一-次写出来的代码是百分之百正确的，代码写好过后要进行充分的测试(
        包括单元测试和集成测试)。作为-名软件开发人员，必须要学会对程序进行测试，也就
        是要学会程序的调试。调试的方法有:
        。凭肉眼看
        。对代码进行编译，以发现语法错误
        。用代码检查工具(如Pclint等)来走查代码
        。对代码进行跟踪调试
        。对程序的日志文件进行分析
```

```c
日志
    ●对代码的单步调试只在代码行数较少的时候比较适用，如教材.上面的程序。但在实际的软
        件项目中，代码少则几千行，多则数万行，用单步调试的方法显然不恰当
        为了跟踪某一变量值的变化， 用该方法可能要花费几个小时，
    	这对工作效率产生了严重影响
    ●为了解决大程序文件代码调试问题，日志系统应运而生。
    ●在程序中的重要地方打印日志，之后对产生的日志进行分析，可找到对应代码的问题
    ●因此，日志文件分析成了大型软件项目中代码调试的主要手段
```

```c
printf做日志输出
    ●常见有人直接用printf输出一些信息和数据来做日志/调试输出
    ●通过运行程序时将输出重定向到文件，就可以保存日志
        nohup ./run > log & :持续运行run,将输出保存到log文件中
        tail -f log :持续查看log文件最新添加的内容,实现实时查看
printf做日志的问题
	●简单的程序调试也许可行，但是在工程中有几个致命的缺点: .
        。无法区分不同的测试级别来输出不同详细程度的日志
        。无法在调试和发布版本中输出不同的日志
        。由于通常不检查printf的返回结果，在嵌入式Linux系统中可能造成磁盘空间用罄导
			致系统崩溃
	●因此需要设计专门的日志函数库来实现日志输出
```

```c
日志库
    ●日志函数的基本功能有:
        。输出一条日志
        。设置当前的日志输出级别
```

```c
日志级别
    ●事有轻重缓急，日志信息也有重要与不重要之分。一般按照重要程度，将日志等级分为几
    类，如:
        enum LOG_ LEVEL {
            LOG_ _NULL,
            //不输出信息
            LOG_ FATAL,
            //严重错误
            LOG_ ERROR,
            //一般错误
            LOG_ _WARN，
            //警告信息
            LOG_ INFO，
            //一般信息
            LOG TRACE,
            //跟踪信息
            LOG_ _DEBUG,
            //调试信息
            LOG ALL,
            //输出全部信息
        }
    ●开发人员根据所要打印的日志的具体情况采用不同的日志等级
```

```c
日志输出函数
    void log. _write(int log_ level,const char* fmt, ...);
    ●利用变长参数函数，就可以实现任意内容的日志输出
    ●log__level表示这条日志信息的级别，当当前设置的输出级别大于该级别时才输出这条
    日志
    ●通常会自动加上时间等信息
    ●实际的日志输出函数要处理诸多特殊情况:
        。输出不一定是到标准输出，通常是文件，甚至可能是串口或网络流
        。是否要将日志以日为单位分文件存储? (每天-个日志文件)
        。是否要将日志以大小为单位分文件存储? (每xxMB-一个日志文件)
        。是否要自动压缩旧的日志文件
        。是否要删除很旧的日志文件(如1年前的)
        。或在存储空间紧张时删除旧的文件
```

```c
日志配置
    ●这些复杂的输出要求通常通过日志配置来实现，有两种常见做法:
        。在Linux这样的系统.上，采用配置文件，程序从配置文件中读入各种设置参数，
            然后通过日志库的设置函数来配置
    	。在嵌入式系统上，则往往采用宏来控制，通过在Makefile中设置不同的宏，
            在日志库中通过条件编译来实现不同的配置
```

```c
按位运算
	C有这些按位运算的运算符:
		& 按位的与
		|按位的或
		~按位取反
		^按位的异或
		<<左移
		>>右移
```

```c
按位与&
	如果(x)i==1并且(y)i==1，那么(x&y)i=1
	否则的话(x&y)i=0
	按位与常用于两种应用
		让某一位或某些位为0: x & 0xFE
		取一个数中的一段: x & 0xFF
```

```c
按位或	|
	如果(x)i==1或(y)i==1，那么(x|y)i= 1
	否则的话， (x|y)i==0
	按位或常用于两种应用: 
		使得一位或几个位为1: x |0x01
		把两个数拼起来: 0x00FF| 0xFF00
```

```c
按位取反
	(~x)i= 1 - (x)i
	把1位变0，0位变1
	想得到全部位为1的数: ~0
	7的二进制是0111，x| 7使得低3位为1，而
	x&~7，就使得低3位为0
```

```c
逻辑运算vs按位运算
	●对于逻辑运算，它只看到两个值: 0和1
	可以认为逻辑运算相当于把所有非0值都变成1，然后
		做按位运算
	●5&4->4而5&&4->1&1->1
	●5|4->5而5||4->1 | 1-> 1
	●~4->3而!4->!1->0
```

```c
按位异或^
    如果(x)i== (y)i，那么(x ^ y)i= 0
	否则的话，(x ^ y)i== 1
	如果两个位相等，那么结果为0;不相等，结果为1
	如果x和y相等，那么x ^ y的结果为0
	对一个变量用同一个值异或两次，等于什么也没做
	X^y ^y-> X
```

```c
左移<<
	i<<j
	i中所有的位向左移动j个位置，而右边填入0
	所有小于int的类型，移位以int的方式来做，结果是int
	x <<= 1等价于x *=2
	X<<=n等价于x*= pow(2,n)
```

```c
右移>>
	1>>j
	i中所有的位向右移j位
	所有小于int的类型，移位以int的方式来做，结果是int
	对于unsigned的类型，左边填入0
    对于signed的类型，左边填入原来的最高位(保持符号不变)
	x >>= 1等价于x/=2
	x >>= n等价于x/=pow(2,n)
移位的数不要用负数
```

```c
位段
    位段(it-field)是以位为单位来定义结构体(或联合体)中的成员变量所占的空间。
    含有位段的结构体(联合体)称为位段结构。
    采用位段结构既能够节省空间，又方便于操作
	在结构声明中，在每个成员后面加上:<位数>就定义了位段
	把一个int的若干位组合成一个结构
    struct {
        unsigned int leading : 3;
        unsigned int FLAG1: 1;
        unsigned int FLAG2: 1 ;
        int trailing: 11 ;
    };//指明对应成员所占比特
	总的来说，可能放到一个比特里
	可以直接用位段的成员名称来访问
	比移位、与、或还方便
	编译器会安排其中的位的排列，不具有可移植性
	当所需的位超过一个int时会采用多个int
位段应用
	位段用于两种场合:
		节省空间，不过不是很有必要
		表达二进制选项，如寄存器的各个比特，可以如引用一般的结构成员一样方便地引用
```

```
改造:
	隐藏全局变量，化为局部静态变量
	化为结构，专属变量
```

```
栈改造:
	结构体添加灵活成员
```

```c
链表改造:
	双头链表
	命名匹配
	易读性，不应将指针星号列入类型定义
	增加注释，化为函数(复用性)，main应该只调用其他函数，25行为适宜阅读行数
	全局变量
	代码重用
		●这里的add_ tail、 prt、clean函数和具体的业务无关，和具体的链表无关，
			它们可以不经任何修改用于其他程序
		●实现代码重用首先重在思想，在写代码的时候要想着将来，
			而不是局限于满足眼前的需要
		●以下三条基本原则可以遵循:
			o分离数据和操作，让函数通过参数获得要处理的数据，绝不直接访问全局变量
			o分离业务逻辑和通用操作，就像从read中分离出add_ tail,
				通用操作可以打包成库
			o隐藏细节。一开始定义的List结构里只有head，后来加上了tail,但是
				add_ tail 这些函数的原型和List里有什么无关
	隐藏细节-->接口.
        void add_ tail(List* list, int value);
        void prt(const List* list);
        void clean(List* list);
        ●这些函数的原型，和链表的具体实现方式无关，链表可能是:
        	。单向、双向;有无尾指针;有无哨兵结点
        ●这些选项的组合，但是无论是哪种链表，都可以用上述的三个函数的原型来操作，
        	不同的只是List结构里的成员变量，以及函数内部的具体代码
        ●保持这样的函数原型不变，更换不同的链表类型时，使用这三个函数的代码就
        	不需要修改(将w5-6.c的链表改成没有尾指针，需要改哪些部分? )
        ●这三个函数的原型就是接口。通过接口隔离了代码的具体实现，实现了松耦合
	另-种代码重用
        ●将重复使用的代码提取成函数，是代码重用的一种方式
        ●这样的函数可以做成库，供今后的程序使用
        ●但是遍历链表是特殊的，因为遍历的代码是会重复用到的，
        	而不同的是遍历到每一个结点时做的动作
        ●这样就无法采用函数来重用
       		。div2()和prt()里相同的循环无法被重用
        ●有两个解决方案:
            。枚举器
            。代码注入
```

```c
枚举器
    ●当采用不同的方式的链表时，如有无哨兵结点、块链表还是单数据链表，遍历的代码是不
    	相同的
    ●如果想要让应用代码能以相同的函数原型操作链表，可以采用枚举器的方式
    ●C++的STL就是用的枚举器方式
        for ( Iterator<int> p = v. begin(); p!=v.end(); p++ ) {
        	*p...
        }
    ●这种方式能解决对不同形式的链表采用相同的代码接口的要求
    ●但是不能很好地解决遍历代码重用的问题，而且C语言实现不易.
```

```c
代码注入
    ●既然遍历的代码是一样的，不同的只是循环内针对每个结点要做的动作
    ●那么能否把这个动作在调用遍历函数的时候送进去呢?
        static void iterate(const List *list, void (*f)(Node*))
            for ( Node *p = list->head; p; p=p->next ) {
           		f(p);
            }
        }
    ●这个函数的第二个参数是函数指针,指向一个参数为Node*，没有返回值的函数
    ●在遍历到每一个结点时，调用这个函数来处理每个结点
```

```c
char *planets[] = {"Mercury", "Venus', 
	"Barth","Mars", "Jupiter", 
	"Saturn" , "Uranus", "Neptune",
	"Pluto");
//指向字符串的指针的数组
```

```c
命令行信息不仅对操作系统命令可用
    	它对所有程序都是可用的。
    为了能够访问这些命令行参数(C标准中称为程序参数)
    必须把main函数定义为含有两个参数的函数
    这两个参数通常命名为argc和argv:
	int main(int argc, char fargv[]){
		...
    }
	arge (“参数计数")是命令行参数的数量
          (包括程序名本身)
    argv (“参数向量")是指向命令行参数的指针数组
          这些命令行参数以字符串的形式存储
    argv[0]指向程序名，而M从argv[1]到
          argv[argc- 1]则指向余下的命令行参数。
	argv有一个附加元素，即argv[argc]
          这个元素始终是一个空指针。
    空指针是一种不指向任何地方的特殊指针。
		目前只需要知道宏NULL代表空指针就够了。
```

```
按照C89标准，编译器必须最少支持509个字符长的字符串
	字面量。(没错， 就是509. 不要怀疑。)
C99把最小长度增加到了4095个字符。
```

```c
getchar()=getc(stdin)
```

```
●程序可能会稍微快些。程序执行时调用函数通常会有些额外开销一存储上下 文信息、
	复制参数的值等，而调用宏则没有这些运行开销。(C9注意，C99的内联函数(>18.6
	节)为我们提供了-种不使用宏而避免这一开销的办法。 )
●宏更“通用”。与函数的参数不同，宏的参数没有类型。因此，只要预处理后的程序依
	然是合法的，宏可以接受任何类型的参数。例如，我们可以使用MAX宏从两个数中选出
	较大的一个，数的类型可以是int、long、float、 double等 。
	但是带参数的宏也有一些缺点。
●编译后的代码通常会变大。每一-处宏调用都会导致插入宏的替换列表，由此导致程序的
	源代码增加(因此编译后的代码变大)。宏使用得越频繁，这种效果就越明显。当宏调
	用嵌套时，这个问题会相互叠加从而使程序更加复杂。思考一下，如果我们用MAX宏来
	找出3个数中最大的数会怎样?
		n = MAX(i, HAX[j, k));
	下面是预处理后的语句:
		n = ((L)>(((j)>(k)?(j):(k)))?(1):(((J)>(k)?(j):(k11]:
●宏参数没有类型检查。当一个函数被调用时，编译器会检查每一个参数来确认它们是否
	是正确的类型。如果不是，要么将参数转换成正确的类型，要么由编译器产生一条出错
	消息。预处理器不会检查宏参数的类型，也不会进行类型转换。
	,无法用一个指针来指向一个宏。如在17.7节中将看到的，C语言允许指针指向函数，这
	在特定的编程条件下非常有用。宏会在预处理过程中被删除，所以不存在类似的“指向
	宏的指针”。因此，宏不能用于处理这些情况。
	,宏可能会不止次地计算它的参数。函数对它的参数只会计算一次， 而宏可能会计算两
	次甚至更多次。如果参数有副作用，多次计算参数的值可能会产生不可预知的结果。考
	虑下面的例子，其中MAx的一一个参 数有副作用:
		n = MAX(i++, j); 
	下面是这条语句在预处理之后的结果:
		n = ((1++)()2?(++):(j));
	如果i大于j，那么i可能会被(错误地)增加两次，同时n可能被赋予错误的值。
```

```c
宏具有可变参数个数的主要原因是:
	它可以将参数传递给具有可变参数个数的函数，如printf和scanf。下面给出几个例子:
	#define TEST(condition, ...) ((condition)?\
		printf("Passed test:%s\n", #condition): \
		printf(__VA ARGS__))
	...记号(省略号)出现在宏参数列表的最后，前面是普通参数。VA ARGS_ 是一个专用的标
识符，只能出现在具有可变参数个数的宏的替换列表中，代表所有与省略号相对应的参数。(至
少有一个与省略号相对应的参数，但该参数可以为空。)宏TEsr至少要有两个参数，第一 一个参
数匹配condition,剩下的参数匹配省略号。
```

```c
C99的另一个新特性是__func__标识符。
	__ func__ 与预处理器无关
	与许多预处理特性一样，它也有助于调试。
	每一个函数都可以访问_ func_ 标识符
	它的行为很像一个存储当前正在执行的函数的名字的字符串变量。
	其作用相当于在函数体的一开始包含如下声明:
	static const char __func__[] ="function name" ;
	其中function name是函数名。
	__fun__的另一个用法:
    作为参数传递给函数，让函数知道调用它的函数的名字。
```

```c
#if defined 等价于 #ifdef
defined专用于预处理器的运算符
```

```
Error directive:消息
#error 消息
```

```makefile
makefile中:
	每一组代码行称为一条规则
		每条规则的第一行给出了目标文件，
		跟在后边的是它所依赖的文件
	第二行是待执行的命令
		(当目标文件所依赖的文件发生改变时，
		需要重新构建目标文件，此时执行第二行的命令)
创造好makefile后:
	使用make实用程序来构建(或者重新构建)该程序
		通过检查与程序中每个文件相关的时间和日期
		make可以确定哪个文件是过期的，
		然后会调用必要的命令来重新构建程序
makefile中的每个命令前面都必须有一个制表符
	不是一串空格。
makefle通常存储在一个名为Makefile
	(或makefile)的文件中。使用make实用程序时，
	它会自动在当前目录下搜索具有这些名字的文件。
用下面的命令调用make:
make 目标
	其中目标是列在makefile中的目标文件之一。
	为了用我们的makefile构建justify可执行程序，
	可以使用命令
		make justify
如果在调用make时没有指定目标文件，
	将构建第一条规则中的目标文件。 
	例如，命令make
```

```c
许多编译器也支持-U选项，这个选项用于删除宏的定义，
效果相当于#undef.我们可以使用-U选项来删除预定义宏
或之前在命令行方式下用-D选项定义的宏的定义。
```

```c
复合字面量被用于创建没有名字的数组，
	这样做的目的通常是将数组作为参数传递给函数。
复合字面量同样也可以用于“实时”创建一个结构，
	而不需要先将其存储在变量中。
生成的结构可以像参数样传递，可以被函数返回，
	也可以赋值给变量。
part1 =((struct part){528,"Disk drive",10});
print_part((struct part) {.on hand = 10,
.name = "Diak drive" ,.number = 528]) ;
复合字而量不会提供完全的初始化，
    所以任何未初始化的成员默认值为0。
```

```C
C99 由于结构数组(以及包含数组的结构)很常见，
	因此C99的指定初始化式允许每一项具有多个指示符。
```

```
像结构-样，联合(union)也是由一个或多个成员构成的，
	而且这些成员可能具有不同的类型。
但是，编译器只为联合中最大的成员分配足够的内存空间。
联合的成员在这个空间内彼此覆盖。
这样的结果是，给一个成员赋予新值也会改变其他成员的值。
联合的初始化方式甚至也和结构的初始化很类似。
	但是，只有联合的第一个成员可以获待初始值。
C99指定初始化式也可以用在联合中。
指定初始化式允许我们指定需要对
联合中的哪个成员进行初始化。
```

```c
在结构中经常使用联合作为节省空间的一种方法。
用联合来构造混合的数据结构
为联合添加“标记字段”
```

```
C语言为具有可能值较少的变量提供了一种专用类型。
枚举类型(enumeration type)是一种值由程序员列出
("枚举")的类型，而且程序员必须为每个值命名(枚举常量)。
```

```
在系统内部，C语言会把枚举变量和常量作为整数来处理。
默认情况下，编译器会把整数0, 1, 2, 
赋给特定枚举中的常量。
```

C99中允许枚举存在尾逗号，能够更方便修改枚举

```
malloc函数分配内存块,但是不对内存块进行初始化。
calloc函数分配内存块,并且对内存块进行清零。
realloc函数调整先前分配的内存块大小。
```

```c
指向函数的指针:
	先声明函数:
		int fun(int b){
		}
	在声明指针:
		int (*a)(int)=fun;
	调用函数指针:
		(*a)(2);
```

```c
i&=~(1<<j);/* clears bit j*/
```

```
isprint()判断是不是可打印字符(即不是控制字符)
```

