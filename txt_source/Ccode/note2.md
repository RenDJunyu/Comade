声明的形式：声明说明符 声明符

声明说明符：
	储存类型：auto、static、extern、register
		只能出现一种
	类型限定符：const、volatile、restrict(C99)
		可以包含多个
	类型说明符：void char short int long float double
	signed unsigned 还包括结构、联合和枚举的说明，以及typedef创建的类型名
	C99还有第四种，函数说明符，inline

​	类型限定符和类型说明符必须跟在储存类型后边，两者顺序没有限制

​	声明符包括标识符(简单变量的名字)、后边跟随[]的标识符(数组名)、前放置*的标识符(指针名)和后边跟随()的标识符(函数名)

​	register将变量储存到寄存器中，更快

​	避免额外开销：带参数的宏和内联函数

内联定义和register、restrict关键字用于提升程序性能

```c
/******average.h******/
#ifndef AVERAGE_H
#DEFINE AVERAGEH
inline double average(double a， double b){
	return (a .b) 2;
}
#endif
/******average.c******/
#include"average.h"
extern double average(double a,double b);
```

​	具有自动储存期限的变量在所在块开始执行时分配内存空间，对于C99的变长数组在块的执行到达变长数组声明时才会为其分配空间。

​	从程序设计的角度来说，通常不建议将变量放在头文件中，但建议把相关常量放在头文件中

​	C语言提供的唯一封装工具是不完整类型

```c
struct t;
```

​	不能用来声明变量，但是可以用来定义一个指针类型引用不完整类型。

volatile类型限定符可以通知编译器，程序中的某些数据是“易变”的，通常使用在用于指向易变内存空间的指针的声明中

##### 对标准库中所用名字的限制

​	第一，该文件内不能将头中定义过的宏的名字用于其他目的。
​	第二，具有文件作用域的库名(尤其是typedef名)也不可以在文件层次重定义。
​	**由一个下划线和一个大写字母开头或由两个下划线开头的标识符**是为标准库保留的标识符。程序不允许为任何目的使用这种形式的标识符。
​	**由一个下划线开头的标识符**被保留用作具有文件作用域的标识符和标记。除非在函数内部声明，否则不应该使用这类标识符。
​	**在标准库中所有具有外部链接的标识符**被保留用作具有外部链接的标识符。特别是所有标准库函数的名字都被保留。

```c
1.<assert.h>:诊断
仅包含assert宏,允许插入自我检查，检查失败程序中止
2.<ctype.h>:字符处理
提供用于字符分类及大小写转换的函数
3.<errno.h>:错误
提供erron("error number")，erron是一个左值，可以在调用特定函数库后进行检测，来判断调用过程中是否有错误发生
4.<float.h>:浮点类型的特性
提供了用于描述浮点类型特性的宏，包括值的范围和精度
5.<limits.h>:整数类型的大小
提供了用于描述整数类型(包括字符类型)特性的宏，包括它们的最大值和最小值
6.<locale.h>:本地化
提供一些函数来帮助程序适应针对某个国家或地区的特定行为方式。这些与本地化相关的行为包括显示数的方式(如用作小数点的字符)、货币的格式(如货币符号)、字符集以及日期和时间的表示形式
7.<math.h>:数学计算
提供了常见的数学函数，包括三角函数、双曲函数、指数函数、对数函数、幂函数、邻近取整函数、绝对值运算函数以及取余函数
8.<setjmp.h>:非本地跳转
提供了setjmp函数和1ongjmp函数。setjmp函数会“标记”程
序中的一个位置，随后可以用1ongjmp返回被标记的位置。这些函数可以用来从一个函数跳转
到另一个（仍然活动中的）函数中，而绕过正常的函数返回机制。setjmp函数和longjmp函数
主要用来处理程序执行过程中出现的严重问题。
9.<signal.h>:信号处理
提供了用于处理异常情况（信号）的函数，包括中断和运行时
错误。signal函数可以设置一个函数，使系统会在给定信号发生后自动调用该函数;raise函
数用来产生信号。
10.<stdarg.h>:可变参数
提供了一些工具用于编写参数个数可变的函数，就像printf和
scanf函数一样。
11. stadef.h>:常用定义
提供了经常使用的类型和宏的定义。
12.<stdio.h>:输入/输出
提供了大量的输入/输出函数，包括对顺序访问和随机访
问文件的操作。
13.<std1ib.h>:常用实用程序
包含了大量无法划归其他头的函数。包含在<stdlib.>中的函
数可以将字符串转换成数，产生伪随机数，执行内存管理任务，与操作系统通信，执行搜索与
排序，以及在多字节字符与宽字符之间进行转换。
14. <string.h>:字符串处理
提供了用于进行字符串操作（包括复制、拼接、比较及搜索)
的函数以及对任意内存块进行操作的函数。
15.<time.h>:日期和时间
<time.h>头(26.3节）提供相应的函数来获取时间（〈和日期)，操纵时间，以及格式化时
间的显示。
```

```c
C99对标准库的改变主要分为以下三个类。
	新增头。在C99标准库中有9个头是C89中没有的。事实上其中三个(<iso646.h>、
<wchar.h>和<wctype.h>）在1995年修订C89时就增加到了C中，另外6个
(<complex.h>、fenv.h>、<inttypes.h>、<stdbool.h>、<stdint.h>和<tgmath.h>)
是C99新增的。
	新增宏和函数。C99标准在一些已有的头中增加了宏和函数，这些头主要有<float.h>、
<math.h>和<stdio.h>。在<math.h>头中增加了非常多的内容，我们将专门用一节(23.4
节）来讲述。
	对已有函数的改进。一些已存在的函数（包括printf和scanf）在C99中具有了更多的
功能。
接下我们快速浏览一下C99标准库中新增的9个头，就像在21.2节浏览C89库中的头一样。
1.<complex.h>:复数算术
定义了complex和工宏，这两个宏对于复数运算来说非常有用。
该头还提供了对复数进行数学运算的函数。
2.<fenv.h>:浮点环境
提供了对浮点状态标志和控制模式的访问。例如，程序可以测试
标志来判断浮点数运算过程中是否发生了溢出，或者设置控制模式来指定如何进行取整。
3.<inttyDes.h>:整数类型格式转换
定义了可用于<stdint.h>中声明的整数类型的输入/输出的格
式化字符串的宏，还提供了处理最大宽度整数的函数。
4.<iso646.h>:拼写转换
定义了可代表特定运算符（包含字符&、|、~、!和~的运算符)
的宏。当编程环境的本地字符集没有这些字符时，这些宏非常有用。
5.<stdboo1.h>:布尔类型和值
定义了bool、true和false宏，同时还定义了一个可以用于测
试这些宏是否已被定义的宏。
6. <staint.h>:整数类型
声明了指定宽度的整数类型并定义了相关的宏（例如指定每种
类型的最大和最小值的宏)。同时定义了用于构建具体类型的整数常量的带参数的宏。
7. <tgmath.h>:泛型数学
在C99中，<math.h>和<complex.h>头中的许多数学函数都有多个版本。
中的泛型宏可以检测传递给它们的参数的类型，并替代为相应<math.h>或
<complex.h>中函数的调用。
8.<wchar.h>:扩展的多字节和宽字符实用工具
提供了宽字符输入/输出和宽字符串操作的函数。
9. <wctype.h>:宽字符分类和映射实用工具
是<ctype.h>的宽字符版本，提供了对宽字符进行分类和修改
的函数。
```

```c
<stddef.h>头提供了常用类型和宏的定义，但没有声明任何函数。

	ptrdiff_t。当进行指针相减运算时，其结果的类型。
	size_t。 sizeof运算符返回的类型。
	wchar_t。一种足够大的、可以用于表示所有支持的地区的所有字符的类型。
所有这3种类型都是整数类型。其中ptrdiff_t必须是有符号类型，而size_t则必须是无符号类
型。
<stddef.h>头中还定义了两个宏。一个是NULL，用来表示空指针。另一个宏offsetof需
要两个参数:类型（一种结构类型）和成员指示符（结构的一个成员)。offsetof宏会计算结
构的起点到指定成员间的字节数。
```

```c
<stdbool.h>头定义了4个宏:
    bool（定义为_Bool);
    true（定义为1)
    false（定义为o）;
    _bool_true_false_are_defined（定义为1)。
```

```c
FILE *freopen {const char* restrict filename,
const char *restrict mode,FILE* restrict stream) ;
	freopen函数为已经打开的流附加上一个不同的文件。最常见的用法是把文件和一个标准
流(stdin、stdout或stderr)相关联。
	例如，为了使程序开始往文件foo中写数据，可以使用下列形式的freopen函数调用:
if (freopen("Eoo","w",stdout) == NULL) (
	/* error: foo can't be opened*/
在关闭了先前(通过命令行重定向或者之前的freopen函数调用)与stdout相关联的所有文件
之后，freopen函数将打开文件foo,并将其与stdout相关联。
	freopen函数的返回值通常是它的第三个参数(一个文件指针)。如果无法打开新文件，那
么freopen函数会返回空指针。(如果无法关闭旧的文件，那么freopen函数会忽略掉错误。)
	C99新增了一种机制。如果filename是空指针, freopen会试图把流的模式修改为mode
参数指定的模式。不过，具体的实现可以不支持这种特性;如果支持，可以限定能进行哪些模
式改变。
```

<输入stdin重定向，>输出stdout重定向，2>输出stderr重定向，&>输出stdout和stderr重定向

```c
>>追加，将命令的输出结果写入文件
```

tmpfile产生临时文件程序关闭或者手动关闭后就会删除，tmpnam产生临时文件名

确保tmpnam函数所指向的数组至少有L_ tmpnam个字符。此外，还要当心不能过于频繁地调用tmpnam函数。宏TMP_ MAX (在<stdio . h>中定义)指明了程序执行期间由tmpnam函数产生的临时文件名的最大数量。如果生成文件名失败，tmpnam返回空指针。

fflush(fp)为和fp相关联的文件清洗了缓冲区
fflush(NULL)清洗全部输出流

​	setvbuf函数允许改变缓冲流的方法，并且允许控制缓冲区的大小和位置。函数的第三个实际参数指明了期望的缓冲类型，该参数应为以下三个宏之一。

```c
_IOFBF(满缓冲),当缓冲区为空时，从流读入数据;当缓冲区满时，向流写入数据
_IOLBF(行缓冲),每次从流读入数据或者直接向流写入数据，而没有缓冲区
_IONBF(无缓冲),直接从流读入数据或者直接向流写入数据，而没有缓冲区
所有这三种宏都在<stdio.h>中进行了定义，对于没有交互式设备相连的流来说，满缓冲都是默认配置
```

setvbuf函数的第二个参数(如果不是空指针的话)时期望缓冲区的地址，缓冲区可以有静态存储期限、自动存储期限，甚至可以是动态分配的。使缓冲区具有自动存储期限可以在块退出时自动为其重新申请空间。动态分配缓冲区可以在不需要时释放缓冲区。setvbuf函数的最后一个参数是缓冲区内字节的数量。较大的缓冲区可以提供更好的行能，而较小的缓冲区可以节省空间。

```c
fprintf可以用于任何的输出流，最常见的应用之一
(向标准错误流stderr写入出错信息)和磁盘文件是没有
任何关系的。可以保证消息能出现在屏幕上，即使用户从定向stdout
```

![image-20200731180314108](D:/Typora/resources/storepics/image-20200731180314108.png)

```apl
printf转换说明
	标志(可选项，允许多于一个):
		-在字段内左对齐(默认右对齐)
		+有符号转换得到的数总是以+或-开头(通常，只有符输前面附上减号)
		空格 有符号转换得到的非负数前面加空格(+标志优先于空格标志)
		#以0开头的八进制数，以0x或0X开头的十六进制非零数。浮点数始终有小数点，不能删除由g或G转换输出的尾部零
		0(零) 用前导零在数的字段宽度内进行填充。如果转换是d、i、o、u、x或X，而且指定了精度，那么可以忽略标志0(-标志优先于0标志)
	最小字段宽度(可选项)。
		如果数据项太小以至于无法达到这一宽度，那么会对字段进行填充。(默认情况下会在数据项的左侧添加空格，
		从而使其在字段宽度内右对齐。)如果数据项过大以至于超过了这个宽度，那么会完整地显示数据项。字段宽度既可以是整数也可以是字符*。
		如果是字符，那么字段宽度由下一个参数决定。如果这个参数为负，它会被视为前面带-标志的整数
	精度(可选项)。
		精度的含义依赖于转换说明符:如果转换说明符是d i o u x X,那么精度表示最少位数(如果不够，则前面添加前导零);如果转换符是a A
		e E f F,那么精度表示小数点后的位数；如果转换说明符是g G,那么精度表示有效数字的个数;如果转换说明符是s,那么精度表示最大字节
		数。精度是由小数点(.)后跟一个整数或字符*构成的。如果出现字符*，那么精度由下一个参数决定(如果这个参数为负，效果与不指定精度
		一样)。如果只有小数点，那么精度为0
	长度修饰符(可选项)。
		长度修饰符表明待显示的数据项类型的长度大于或小于特定转换说明符中的正常值(未给出的长度修饰符和转换说明符的结合会引起未定义
		的行为)
	转换说明符。
		转换说明符必须是列出的某一种字符。注意f F e E g G a A全部设计用来输出double类型的值，但是把它们用于float类型的值也可以;
		由于有默认的实际参数提升,float类型实参在传递给代有可变数量参数的函数时会自动转换为double类型。char也会转化为int,所以可以
		正常地使用转换说明符c。使用无效的转换说明符会导致未定义的行为
C99改变
	增加了长度修饰符
	增加了转换说明符
	允许输出无穷数和NaN(Linux)或IND(Windows)(非数)
	支持宽字符
	之前未定义的转换说明现在允许了
```

![image-20200802181818024](D:/Typora/resources/storepics/image-20200802181818024.png)![image-20200802182704154](D:/Typora/resources/storepics/image-20200802182704154.png)

```elm
fscanf和scanf
	如果发生输入失败(即没有输入字符可以读)或者匹配失败(即输入字符和格式串不匹配),那么.scanf函数会提前返回
	(在C99中,输入失败还可能由编码错误导致。编码错误意味着我们试图按多字节的方式读取输入，但输入字符却不是
	有效的多字节字符)这两个函数都返回读入并且赋值给对象的数据项的数量。如果在读取任何数据项之前发生输入失
	败，那么会返回EOF
```

```haskell
scanf格式串
	转换说明。
		.scanf函数格式串中的转换说明类似于.printf函数格式串中的转换说明。
		大多数转换说明(%[、%c和%n例外)会跳过输入项开始处的空白字符。但是转换说明不
		会跳过尾部的空白字符
	空白字符
		.scanf函数格式串中的一个或多个连续的空白字符与输入流中的零个或多个空白字符相匹配
	非空白字符
		除了%之外的非空白字符和输入流中的相同字符相匹配。
		格式串中说明输入由格式串中的内容构成
```

```livescript
.scanf转换说明
	字符*(可选项)。
		字符*的出现意味着赋值屏蔽：读入此数据项，但是不会把它赋值给对象。
		用*匹配的数据项不包含在scanf函数返回的计数中
	最大字符宽度(可选项)。
		最大字段宽度限制了输入项中的字符数量。如果达到了这个最大值，那么
		次数据项的转换将结束。转换开始处跳过的空白字符不进行统计
	长度修饰符(可选项)。
		长度修饰符表明用于储存出入数据项的对象的类型与特定转换说明中的
		常见类型长度不一致。(没有给出的长度修饰符和转换说明符的结合会
		引起未定义的行为)
	转换说明符
		必须是列出的某一种字符
	
	数值型数据项可以始终用符号(+或-)作为开头，但说明符o u x X把数据项
	转换成无符号的形式，所以通常不用这些说明符来读取负数
	
	说明符[是说明符s更加复杂(且更加灵活)的版本。使用[的完整转换说明格式
	是%[集合]或者%[^集合],这里的集合可以是任意字符集。(但是，如果]是集
	合中的一个字符，那么它必须要首先出现。)%[集合]匹配集合(即扫描集合)中
	的任意字符序列。%[^集合]匹配不在集合中的任意字符序列(换句话说，构成扫
	描集合的全部字符都不在集合中)。
	
C99改变
	增加了长度修饰符
	增加了转换说明符
	具有读无穷数和NaN的能力
	支持宽字符
```

![image-20200803161045023](D:/Typora/resources/storepics/image-20200803161045023.png)![image-20200803161202013](D:/Typora/resources/storepics/image-20200803161202013.png)![image-20200803163442105](D:/Typora/resources/storepics/image-20200803163442105.png)

```markdown
scanf读入错误可能情况：
	文件末尾：函数在完全匹配格式串之前遇到了文件末尾
	读取错误：函数不能从流中读取字符
	匹配失败：数据项的格式是错误的
	
每个流都有与之相关的两个指示器：错误指示器和文件
末尾指示器，当打开流时会清除这些指示器，遇到文件
末尾就设置文件末尾指示器，遇到读错误就设置错误指
示器。(输出流上发生写错误时也会设置错误指示器)。
匹配失败不会改变任何一个指示器

	一旦设置了错误指示器或者文件末尾指示器，它就会保
	持这种状态直到被显式清楚(可能通过clearerr函数的
	调用)。clearerr会同时清除文件末尾指示器和错误指
	示器。
	
通过调用feof函数和ferror函数来测试流的指示器
	如果为与fp相关的流设置了文件末尾指示器，那么feof
	(fp)函数调用就会返回非零值，如果设置了错误指示器，
	那么ferror(fp)的调用也会返回非零值
```

```perl
字符的输入/输出
	输出函数
		int fputc(int c,FILE *stream);
		int putc(int c,FILE *stream);
		int putchar(int c);
	putchar函数向标准输出流stdout写一个字符
	fputc和putc是putchar向任意流写字符的更通用的版本
	虽然二者工作相同，但是putc通常作为宏来实现(也有
	函数实现)，而fputc则只作为函数实现
	putchar本身通常也定义为宏
		#define putchar(c) putc((c),stdout)
	C标准允许putc宏对stream参数多次求值，而fputc不可以
	如果出现了写错误，3个函数都会为流设置错误指示器并
	返回EOF,否则都会返回写入的字符
	
	输入函数
		int fgetc(FILE *stream);
		int getc(FILE *stream);
		int getchar(void);
		int ungetc(int c,FILE *stream);
	getchar函数从标准输入流stdin中读入一个字符
	fgetc函数和getc函数从任意流中读入一个字符
	3ge函数都把字符看成unsigned char类型的值(返回之前
	转换成int类型)。因此不会返回EOF之外的负值
	getc通常作为宏来实现(也有函数实现),而fgetc只作为
	函数实现。getchar通常也定义为宏
		#define getchar() getc(stdin)
	如果作为宏形式的putc和getc不合适，可以用fput和fgetc
	作为备选
	如果遇到文件末尾，3个函数会设置流的文件末尾指示器，并
	返回EOF。产生了读错误，会设置流的错误指示器，并返回EOF
	始终要把3个函数的返回值储存在int型的变量中，char类型与
	EOF进行比较可能会得到错误的结果
	
	 还有一种字符输入函数，即ungetc函数，此函数把从流中读入
	的字符“放回”并清楚流的文件末尾指示器，如果在输入过程中
	需要往前多看一个字符，这个函数会非常有效
	 通过持续调用ungetc函数而放回的字符数量(不干涉读操作)
	依赖于实现和所含的流类型。只有第一次的ungetc函数调用
	是保证会成功的。调用文件定位函数(fseek、fsetpos或
	rewind)会导致放回的字符丢失
	 ungetc返回要求放回的字符，如果试图放回EOF或者式图放回
	超过最大允许数量的字符数，ungetc会返回EOF
```

```objective-c
行的输入/输出
	输出函数
		int fputs(const char * restrict s,FILE * restrict stream);
		int pust(const char * s);
	在写入字符串中的字符移后，puts函数总会添加一个换行符
    fputs函数是puts函数的更通用版本。此函数的第二个实参指明了输出要写入的流
    不同于fputs函数,fputs函数不会自己写入换行符，除非字符串中本身含有

    输入函数
        char *fgetc(char *restrict s,int n,FILE *restrict stream);
		char *gets(char *s);
	gets函数逐个读取字符，并且把它们储存在str所指向的数组中，直到它读到
    换行符时停止(丢弃换行符)
    fgets函数是gets函数的更通用版本，它可以从任意流中读取信息。
    fgets函数也比gets函数更安全，因为它会限制将要存储的字符的数量(n-1个)
    如果出现了读错误，或者是在储存任何字符之前达到了输入流的末尾，那么gets
    函数和fgets函数都会返回空指针，。否则都会返回自己的第一个实参。与预期
    一样，两个函数都会在字符串的末尾存储空字符
```

```
块的输入/输出
	
```



### TODO P424

