# 鸟哥的Linux私房菜

## 一、Linux的基本介绍

### Linux是什么

    Linux是操作系统
    苹果2006年前使用power PC，之后使用x86
    Linux是GNU GPL授权模式，任何人均可取得原始码与可执行这个核心程序，并且可以修改。因为Linux参考POSIX设计规范，于是兼容于Unix操作系统，故可称为Unix Like
    GNU(GNU is Not Unix)计划，倡导自由软件，强调软件可以自由的取得、复制、修改与再发行，并规范GPL授权模式，任何GPL软件均不可单纯仅贩卖其软件，也不可修改软件授权。

## 二、主机规划与磁盘分区

### 2.1 Linux与硬件的搭配

    各个组件或装置在Linux底下都是一个文件，几乎所有的硬件装置文件都在/dev这个目录内。
        装置                装置在Linux内的文件名
        SCSI/SATA/USB硬盘机 /dev/sd[a-p]
        USB快闪碟           /dev/sd[a-p]（与SATA相同）
        VirtI/O界面         /dev/vd[a-p]
        软盘驱动器          /dev/fd[0-7]
        打印机              /dev/lp[0-2]（25针打印机）
                            /dev/usb/lp[0-15]（USB界面）
        鼠标                /dev/input/mouse[0-15]（通用）
                            /dev/psaux（PS/2界面）
                            /dev/mouse（当前鼠标）
        CDROM/DVDROM        /dev/scd[0-1]（通用）
                            /dev/sr[0-1]（通用，CentOS较常见）
                            /dev/tape（当前磁带）
        IDE硬盘机           /dev/hd[a-d]（旧式系统才有）
            甚至会被仿真为/dev/sd[a-p]
        虚拟机内的磁盘是使用仿真器产生，磁盘文件名为/dev/vd[a-p]

### 2.2 磁盘分区

    一个磁盘能够被分为多个分区槽
    磁盘连接的方式与装置文件名的关系
        个人计算机常见的磁盘接口有，SATA和SAS，前者为主流。
        SATA/USB/SAS等磁盘接口使用SCSI模块来驱动，因此这些接口的磁盘装置文件名都是/dev/sd[a-p]格式。装置文件名根据Linux内核侦测磁盘的顺序
        早期磁盘第一个扇区里面还有的重要信息称为MBR(Master Boot Record)格式，对于更大容量的，磁盘分区格式为GPT(GUID partition table)。
    MSDOS(MBR)与GPT磁盘分区表
        通常磁盘可能有多个磁盘盘，所有磁盘盘的同一个磁道称为磁柱，通常是文件系统的最小单位，也是分区槽的最小单位。GPT可以达到64bit记录功能的分区表，可以使用扇区号码来作为分区单位。利用参考对照磁柱或扇区号码的方式来处理。
        MBR分区表格式与限制
            早期的Linux系统为了兼容于Windows的磁盘，因此使用的是支持Windows的MBR的方式来处理开机管理程序与分区表。而开机管理程序记录区与分区表则放在磁盘的第一个扇区，通常是512bytes的大小（前者安装开机管理程序，446bytes，后者记录整颗磁盘分区的状态，64bytes），分区表最多有四组记录区，被称为主要或延伸分区槽，每组记录区记录了该区段的起始与结束的磁柱号码。当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区槽进行数据的处理。
            分区的目的：数据的安全性，系统的效能考虑
            通过延伸分区的方式将硬盘分区为十个以上，分布在每个分区槽的最前面几个扇区来记录分区信息。延伸分区本身并不能被拿来格式化。延伸分区继续切出来的为逻辑分区槽。四组记录区为/dev/sda[0-3]，逻辑分区槽从sda5开始
        GPT磁盘分区表
            为了兼容于所有的磁盘，在扇区的定义上面，大多会使用逻辑区块地址LBA来处理。GPT将磁盘所有区块以LBA来规划，第一个为LBA0
            GPT使用了34个LBA区块来记录分区信息，整个磁盘的最后33个LBA也拿来作为另一个备份。
                LBA0(MBR相容区块)，与MBR模式相似，这个兼容区块分为两个部分。而原本的分区表的记录区内，这个兼容模式仅放入了一个特殊标志的分区，用来表示此磁盘为GPT格式。除非用户有特别要求处理这颗磁盘，否则该管理软件不能修改此分区信息。
                LBA1(GPT表头记录)，这个部分记录了分区表本身的位置与大小，同时记录了备份用的GPT分区放置的位置，同时放置了分区表的检验机制码(CRC32)，操作系统可以根据这个检验码来判断GPT是否正确。若有错误，还可以通过这个记录区来取得备份的GPT来恢复GPT的正常运作
                LBA2-33(实际记录分区信息处)，从LBA2区块开始，每个LBA都可以记录4笔分区记录，每笔记录128bytes，每笔记录提供64bits来记载开始/结束的扇区号码。
            Linux本身的核心装置记录中，针对单一磁盘，最多只能达到15个分区槽，但内核通过udev等方式处理，也取消了这个限制。GPT分区没有主、延伸、逻辑分区的概念，每个都可以视为主分区并被格式化使用。
    开机流程中的BIOS与UEFI开机检测顺序
        CMOS是记录各项硬件参数且嵌入在主板上的存储器，BIOS是写入到主板上的一个韧体(写入到硬件上的一个软件程序)。BIOS是开机时，计算机系统会主动执行的第一个程序。BIOS会依据使用者的设定去取得能够开机的硬盘，并且到该硬盘里面去读取第一个扇区的MBR位置。446bytes的MBR会放置最基本的开机管理程序，目的是加载核心文件，该程序认识硬盘内的文件系统格式。
        LAB0仅提供第一阶段的开机管理程序代码，如果使用类似grub的开机管理程序，要额外分出一个BIOS boot的分区槽，这个分区槽能够放置其他开机过程所需的程序代码，在CentOS当中该分区槽通常占用2MB左右
        boot loader的主要任务：提供选单即不同的开机项目，载入核心文件即直接指向可开机的程序区段来开始操作系统，转交其他loader。开机管理程序除了可以安装在MBR之外，还可以安装在每个分区槽的启动扇区
        Linux安装时可以选择将开机管理程序安装在MBR或个别分区槽的启动扇区，并且loader可以手动设定选单；Windows在安装时，会主动覆盖掉MBR以及所在分区槽的地洞扇区
        UEFI BIOS搭配GPT开机的流程
            GPT可以提供到64bit的寻址，能够使用较大的区块来处理开机管理程序，但BIOS不能识别GPT，需要通过GPT提供兼容模式才能读写这个磁盘装置。BIOS为16位程序，与新操作系统相对落后，从而有UEFI这个统一可延伸韧体界面
            UEFI主要是想取代BIOS，故称为UEFI BIOS。UEFI使用C程序语言，甚至可以在UEFI开机阶段就让该系统了解TCP/IP而直接上网
                比较项目        传统BIOS        UEFI
                使用程序语言    汇编语言        C语言
                硬件资源控制    使用中断IRQ管理 使用驱动程序与协议
                            不可变的内存存取
                            不可变的输入/输出存取
                处理器运作环境  16位            CPU保护模式
                扩充方式        通过IRQ连接     直接加载驱动程序
                内建简化操作系统前环境  不支持  支持
            使用UEFI接口的主机，在开机的速度上要比BIOS快许多
            UEFI的控制方式，包括硬件资源的管理使用轮询(polling)的方式，与BIOS的中断方式相比，效率较低。并且不能提供完整的快取功能，执行效率不能提升。但是加载所有的UEFI驱动程序后，系统会开启一个类似操作系统的shell环境，用户可以在此环境中执行任意的UEFI应用程序，效果比MSDOS更好
            当加载操作系统后，一般来说，UEFI就会停止工作，并将系统交给操作系统。在某些特定的环境下，这些UEFI程序可以部分继续执行，以协助某些操作系统无法找到特定装置时，装置能够持续运作。
            过去黑客经常通过BIOS开机阶段来破坏系统，并取得系统的控制权，因此UEFI加入了安全启动机制，代表即将开机的操作必须要被UEFI验证，否则无法开机。微软使用了较多这样的机制，可能会导致包括Linux在内的操作系统无法开机
            UEFI虽然可以直接取得GPT的分区表，但最好保留BIOS boot的分区槽支持，并且为了与windows兼容，并且提供其他第三方厂商所使用的UEFI应用程序存储的空间，必须要格式化一个vfat的文件系统，512MB-1G，使得其他UEFI执行较为方便
            由于UEFI已经克服了BIOS的1024磁柱的问题，因此开机管理程序与核心可以放置在磁盘开始的前2TB为之内。加之BIOS boot以及UEFI支持的分区槽，基本上/目录都是/dev/sda3之后的号码
        Linux安装模式下，磁盘分区的选择
            目录树结构：整个Linux系统最重要的地方就是在于目录树架构。以根目录为主，然后向下呈现分枝状的目录结构的一种文件架构。根目录(root directory)的表示方法为/，所有的文件都与目录树有关。
            文件系统与目录树的关系(挂载)：挂载就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下，进入该目录就可以读取该分区槽。该动作称为挂载，进入该点的目录称为挂载点。根目录一定需要挂载到某个分区槽，其他的目录可以根据用户自己的需求来挂载到不同的分区槽

## 三、安装(省略)

## 四、基本操作

    退出exit，注销Linux，离开系统并不是关机

### 4.2 文本模式下指令的下达

    开始下达指令
        command [-options] parameter1 parameter2 ...
            加入选项设定使用-，使用选项的完整全名--
            Enter后指令立即执行，使用\来转义Enter
            Linux中大小写不一样
            第一个被输入的数据一定是指令或者是可执行的文件
        ls -al ~ 列出home下的所有隐藏文档与相关的文件属性
            ls -a -l ~
        date 列出日期时间
    语系的支持
        locale 显示目前所支持的语系
            LANG=en_US.utf8，修改为英文语系，注意等号两边没有空格符
            export LC_ALL=en_US.utf8，LANG至于输出信息有关，其他信息需要同步更新LC_ALL
            /etc/locale.conf为对应设置文件
    基础指令的操作
        显示日期
            date 星期、月、日、时间、时区、年
            date +%Yy/%Mm/%Dd，格式设定（选项参数可带+、-
        显示日历
            cal [mouth] [year]
            cal year，显示一年
        计算器
            bc
            + - * / ^ %
            scale=n，小数点位数
            quit退出
        快捷键
            tab，指令补全与文件补齐，按一次补全最近的，两次列出前缀词
                在指令的第一个字后面，指令补全，第二个字后面，文件补齐
                bash-completion软件，能够进行选项/参数补齐
            Ctrl-c，中断目前程序
            Ctrl-d，键盘输入结束(EOF)，可以取代exit
            Shift+PageUp/PageDown，翻页
        注意错误信息

### 4.3 Linux系统的在线帮助man page与info page

    指令的--help求助说明
        主要针对使用过的指令所具备的选项与参数
    man page
        man command进入(manual)，空格翻页，q退出
        command(n)数字意义
            1 用户在shell环境中可以操作的指令或可执行文件
            2 系统核心可呼叫的函数与工具等
            3 一些常用的函数或函数库，大部分为C的函数库
            4 装置文件的说明，通常在/dev下的文件
            5 配置文件或者是某些文件的格式
            6 游戏
            7 惯例与协议等，例如Linux文件系统、网络协议、ASCII code等的说明
            8 系统管理员可用的管理指令
            9 跟kernel有关的文件
            具体可通过man man 获得详细说明
        man null->NULL(4)为装置文件
        内容划分
            代号        内容说明
            NAME        简短的指令、数据名称说明
            SYNOPSIS    简短的指令下达语法简介
            DESCRIPTION 较为完整的说明
            OPTIONS     针对SYNOPSIS部分中，有列举的所有可用的选项说明
            COMMANDS    当这个程序(软件)在执行的时候，可以在此程序(软件)中下达的指令
            FILES       这个程序或数据所使用、参考或链接到的某些文件
            SEE ALSO    可以参考的，跟这个指令或数据有相关的其他说明
            EXAMPLE     一些可以参考的范例
            另外可能有Authors、Copyright
        任何时候可以输入关键词搜索
        快捷键
            空格        向下翻页
            PageDown    向下翻页
            PageUp      向上翻页
            Home        第一页
            END         最后一页
            /string     向下搜索
            ?string     向上搜索
            n,N         利用/或?搜索字符串时，用n来继续下一个搜索，N进行反向搜索
            q           结束man page
        man page通常放在/usr/share/man内，/etc/man_db.conf可以修改man page的搜索路径
        搜索特定指令/文件的man page说明文件
            需要使用某些特定的指令或者是修改某些特定的配置文件，如果忘记指令的完整名称，
                记得指令完整名称，通过man -f name获取man page列表。然后通过man n name打开对应的man page，如果没有n则是默认显示先搜索到的说明文档
                记得关键词，man -k keyword，只要有关键词就会被列出来
                whatis name     等价于  man -f，whatis需要建立数据库，通过mandb来建立
                apropos keyword 等价于  man -k
    info page
        所有的Unix Like系统中，都可以用man来查询指令或者是相关文件的用法。Linux额外提供了info。
        info与man的用途相似，但info page将文件数据拆成段落，每个段落用单独页面撰写，并且还有超链接来进行跳转，每个独立页面被称为节点。
        要查询的目标数据的说明文件必须要以info格式才能使用info，默认放在/usr/share/info中。
            x   关闭help窗口    q   退出info    h   进入info页面    H   help
            Up/Down 上下翻页    Del 回滚        SPC 前翻
            Enter   超链接进入  (Shift)Tab  在超链接间跳转
            空格/PageDown   向下翻页    PageUp  向上翻页
            b   移动到第一个node    e   移动到最后一个node
            n   下一个node  p   上一个node  u   向上移动一层
            s(/,?)在info page中寻找 
    其他有用的文件
        /usr/share/doc中，有较为丰富的说明文件

### 4.4 超简单文本编辑器:nano

    nano filename，存在则打开，不存在则新建
        ^(Ctrl)G/F1    取得联机帮助    ^X  离开nano，如果有修改需要保存
        ^O  存储文件(前提是具有权限) ^R 从其他文件读入资料，并将某个文件的内容附加在文件中
        ^W  搜索字符串  ^C说明当前光标所处的行数与列数等信息
        ^_  直接输入行号，让光标快速移动到该行  alt-T 校正语法功能开启或关闭
        alt-M 支持鼠标来移动光标

### 4.5 正确的关机方法

    在Linux底下，每个程序(或服务)都是在背景下执行的，可能有多人同时在主机上工作。而且如果不正常关机，可能造成文件系统的损坏。
    观察系统的使用状态
        查看目前在线用户    who
        查看网络的联机状态  netstat]
        查看背景执行的程序  ps -aux
    正确的关机指令
        shutdown,reboot
    数据同步写入磁盘    sync
        shutdown/reboot/halt等指令在关机前已经进行了sync工具调用
        su ~    变为root
        非root进行sync只能同步自己的数据
    惯用的关机指令  shutdown
        可以自由选择关机模式、设定关机时间、自定义关机信息、仅发出警告信息
        /sbin/shutdown [-krhc] [时间] [警告信息]
            -k 不关机，只是发出警告信息
            -r 在将系统的服务停掉之后就重新启动
            -h 将系统的服务停掉后，立即关机
            -c 取消已经在进行的shutdown指令内容
            时间 指定系统关机的时间，默认1min，单位min，now为立即，+-进行时间增减，也可以指定时刻
    重新启动，关机:reboot,halt,poweroff
        三个指令的函数库相似，所以man reboot会同时将三个指令列出‘
        预设的情况下，三个指令都会完成调用systemctl
        halt:系统停止，屏幕可能会保留系统已经停止的信息
        poweroff:系统关机
        init能够切换不同的执行等级，0~6，0为关机，6为重新启动，init只是兼容模式
        所有服务的管理使用systemctl
            systemctl command
                halt，进入系统停止的模式
                poweroff，进入系统关机模式
                reboot，直接重新启动
                syspend，进入休眠模式

## 五、Linux的文件权限与目录配置

    Linux最优秀的地方之一在于多人多任务环境，为了让各个使用者具有较为保密的文件数据，文件的权限管理很重要。Linux一般将文件可存取的身份分为：owner/group/others，各自的read/write/execute权限不同

### 5.1 使用者与群组

    owner/group/others
        文件拥有者：同一群组的使用者，可以设定权限，保有使用者的私密空间
        群组：每个账号可以有多个群组的支持
        其他人，包含root
    Linux用户身份与群组记录的文件
        默认情况下，所有的系统上的账号与一般身份使用者，都记录在/etc/passwd内，个人密码记录在/etc/shadow内。Linux所有的组名都记录在/etc/group内。

### 5.2 Linux文件权限概念

    Linux文件属性
        ls -al：权限 链接 拥有者 群组 文件大小 修改日期 文件名
            文件名第一个字符为.的文件为隐藏文件
            权限栏一共有10个字符，文件类型、文件拥有者权限3(rwx)、文件所属群组权限3(rwx)、其他人权限3(rwx)，-为无权限
                文件类型：d为目录，-为文件，l为链接文件，b为装置文件内可供存储的接口设备(可随机存储装置)、c为装置文件内串行端口设备(一次性读取装置)
                权限：无论是哪一组权限，都是针对账号来设计的权限
                    目录与文件的权限意义并不相同，因为目录与文件所记录的数据内容不相同
            链接，表示文件名链接到该结点数目，每个文件都会将他的权限与属性记录到文件系统的i-node中。使用的目录树使用文件名来记录的，所以每一个文件名会链接到一个i-node。
            文件大小默认单位为byte
            修改日期，如果修改时间较远，仅显示年份。ls -l --full-time显示出完整的时间格式
        Linux文件权限的重要性
            系统保护、团队开发软件或数据共享
    如何改变文件属性与权限
        chgrp，改变文件所属群组；chown，改变文件拥有者；chmod，改变文件的权限，SUID、SGID、SBIT等特性
        改变所属群组，chgrp
            被改变的组名必须要在/etc/group文件内存在才行，否则会显示错误
                charp [-R] groupname dirname/filename ...
                    -R进行递归的持续变更，连同次目录下的所有文件、目录都更新成这个群组。
        改变文件拥有者，chown
            用户必须是已经存在系统中的账号，在/etc/passwd文件中有记录的用户名称才能被改变
                chown [-R] usrname[:grpname] dir/filename
            将文件/目录的拥有者(或包括群组)改为对应名称，:也可写为.，省略用户名也可单独修改群组
                cp srcfile desfile，复制文件，同时也会复制权限
        改变权限，chmod
            数字类型改变文件权限，三种身份对应的权限字符二进制表示
                chmod [-R] xyz，分别为own/grp/oth的权限数值
                用vim编辑一个shell的文字批处理文件，权限通常是-rw-rw-r--664，如果要变为可执行文件并且不允许他人修改，即改为-rwxr-xr-x755
                不希望被其他人看到，-rwxr-----740
            符号类型改变文件权限
                通过u g o a分别表示user group others all，
                +-=分别表示加入除去设定
    目录与文件的权限意义
        权限对于文件的重要性
            文件是实际含有数据的地方，包括一般文本文件、数据库内容文件、二进制可执行文件等。windows文件可执行能力是由扩展名来判断的，linux文件是否能被执行，是通过是否具有x的权限来决定的；具有写入的能力，但并没有删除的权限
        权限对目录的重要性
            r为查询目录下的文件名数据
            w为变动该目录结构列表的权限：建立新的文件与目录、删除已经存在的文件与目录、将已存在的文件或目录进行更名、搬移该目录内的文件、目录位置
            x代表用户能否进入该目录成为工作目录(即成为目前所在的目录)
            能否访问文件由r决定，能否访问目录内容由x决定(r只是能够列出)
            mkdir dirname 新建文件夹
            touch filename新建空的文件
        用户操作功能与权限
    Linux文件种类与扩展名
        文件种类
            -，常规文件：纯文本文件、二进制文件、数据格式文件
            d，目录
            l，链接文件
            设备与装置文件：区块设备档b，字符设备文件c
            s，资料接口文件(socket)
            p，数据输送文件(FIFO,pipe)
         Linux文件扩展名
            Linux的文件没有扩展名，具有可执行的权限与具有可执行的程序代码不同。
            可以通过扩展名来了解文件内容
                *.sh：脚本或批处理文件(shell)
                *.Z,*.tar,*.tar.gz,*.zip,*.tgz：经过打包的压缩文件，压缩文件分别为gunzip,tar等
                *.html,*.php：网页相关文件，分别代表HTML和PHP语法的网页文件，.html可以使用网页浏览器直接开启，.php通过client端的浏览器来server端浏览·
            Linux文件长度限制
                使用传统的Ext2/Ext3/Ext4文件系统以及近来被CentOS7当作预设文件系统的xfs，针对文件的文件名长度限制：
                    单一文件或目录的最大允许文件名为255bytes
            Linux文件名的限制
                避免特殊字符：*?<>;&![]|\'"`(){}
                .开头为隐藏文件，-+符号会被用于指令选项

### 5.3 Linux目录配置

    Linux目录配置的依据FHS
        Filesystem Hierarchy Standard标准，希望使用者可以了解到已安装软件通常放置的位置。
                        可分享的                不可分享的
            不变的      /usr(软件放置处)        /etc(配置文件)
                        /opt(第三辅助软件)    /boot(开机与核心文件)
            可变动的    /var/mail(使用者邮件)   /var/run(程序相关)
                       /var/spool/news(新闻组) /var/lock(程序相关)
            可分享的，可以分享给其他系统挂载使用的目录，包括执行文件与用户的邮件等数据，能够分享给网络上其他主机挂载用的目录
            不可分享的，自己机器上运行的装置文件或者是与程序有关的socket文件等
            不变的，有些数据是不会经常变动的，跟随着distribution而不变动。例如函数库、说明文件、系统管理员所管理的主机服务配置文件等
            可变动的：经常改变的数据，例如登录文件、一般用户可自行接收的新闻组等
        FHS针对目录树架构仅定义出三次目录下应该放置的数据
            /(root,根目录):与开机系统有关
            /usr(unix software resource):与软件安装/执行有关
            /var(variable):与系统运行过程有关
            根目录(/)的意义与内容
                所有的目录都是由根目录衍生出来的，同时根目录也与开机/还原/系统修复等动作有关。系统开机时需要特定的开机软件、核心文件、开机所需程序、函数库等文件数据，若系统出现错误时，根目录也必须要包含由能够修复文件系统的程序才行。FHS希望根目录不放在非常大的分区槽，避免出错概率较大。
                FHS标准建议：根目录所在分区槽越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区槽内，保持根目录越小越好。如此不但性能更好，根目录所在的文件系统也不容易发生问题
                    目录    应放置文件内容
                    ***FHS要求必须要存在的目录***
                    /bin    系统有很多放置执行文件的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin内的指令可以被root与一般账号所使用，主要有:cat,chmod,chown,date,mv,mkdir,cp,bash等常用指令
                    /boot   这个目录主要放置开机会使用到的文件，包括Linux内核文件、开机选单与开机所需配置文件等。Linux内核常用文件名为vmlinuz，如果使用的是grub2开机管理程序，还会存在/boot/grub2/目录
                    /dev    在Linux系统上，任何装置与接口设备都是以文件的形式存在于该目录中。只需要通过存取这个目录下的某个文件，就等于存取某个装置。比较重要的文件:/dev/null,/dev/zero,/dev/tty,/dev/loop*,/dev/sd*等
                    /etc    系统的主要配置文件基本都放置在这个目录内，例如人员的账号密码文件、各种服务器的起始文件等。一般来说，这个目录下的各文件属性可以让一般使用者查阅，但是只有root有权利修改。FHS建议不要放置可执行文件在这个目录中。比较重要的文件有：/etc/modprobe.d/,/etc/passwd,/etc/fstab,/etc/issue等。另外FHS还规范几个重要的目录最好存在/etc/下
                        /etc/opt(必要):这个目录放置第三方辅助软件/opt的相关配置文件
                        /etc/X11(建议):与X Window有关的各种配置文件都在这，尤其是xorg.conf这个X Server的配置文件
                        /etc/sgml(建议):与SGML格式有关的各项配置文件
                        /etc/xml(建议):与XML格式有关的各项配置文件
                    /lib    系统的函数库非常多，而/lib放置的则是在开机时会用到的函数库，以及在/bin或/sbin底下的指令会呼叫的函数库。FHS还要求存在:/lib/modules/:主要放置可替换式的内核相关模块
                    /media  放置可移除的装置，包括软盘、光盘、DVD等。常见
                        /media/floppy,/media/cdrom
                    /mnt    可以将某些额外装置暂时挂载到该目录中，与/media相同，只是哟关于暂时挂载
                    /opt    用于第三方辅助软件放置。非原本的distribution提供的软件。以前也放置于/usr/local
                    /run    早期FHS规定系统开机后所产生的各项信息应该要放置到/var/run下，新版的规范到/run。/run可以使用内存来仿真，性能上会好很多
                    /sbin   Linux用来设定系统环境的指令只有root能能够使用，其他用户只能查询。/sbin下为开机过程所需要的，包括开机、修复、还原系统所需要的指令。一些服务器软件程序一般放置到/usr/sbin种。本机自行安装的软件所产生的系统执行文件，放置到/usr/local/bin种。常见的指令包括:
                        fdisk,fsck,ifconfig,mkfs
                    /srv    service，是一些网络服务启动之后，这些服务所需要取用的数据目录。常见的服务例如WWW、FTP等。系统的服务数据如果尚未要提供给因特网任何人浏览的话，预设建议放到/var/lib底下
                    /tmp    让一般用户或者是正在执行的程序暂时放置位置的地方。任何人能够存取，需要定期清理。重要数据不可放置，FHS建议开机时将/tmp都删除
                    /usr    第二层FHS设定
                    /var    第二层FHS设定，主要为放置变动性的数据
                    ***FHS建议可以存在的目录***
                    /home   系统默认的用户主目录。在新增一个一般使用者账号时，默认的用户主目录都会规范到这里。主目录有两种代号
                        ~代表当前用户主目录
                        ~name代表用户name的主目录
                    /lib<qual>  用来存放与/lib不同的格式的二进制函数库，例如支持64位的/lib64函数库
                其他在Linux很重要的目录
                    /lost+found 使用标准的ext2/ext3/ext4文件系统格式产生的一个目录，目的在于文件系统发生错误时，将一些遗失的片段放置到该目录。如果使用的是xfs文件系统，不会存在该目录
                    /proc   该目录本身是一个虚拟文件系统。放置的数据都是在内存当中，例如系统内核、程序信息、附属设备的状态和网络状态等。因为这个目录下的数据都是在内存当中，所以本身不占任何硬盘空间。比较重要的文件
                        /proc/cpuinfo,/proc/dma,/proc/interrupts,/proc/ioports,/proc/net/*等
                    /sys    这个目录与/proc相似，也是一个虚拟的文件系统，主要是记录内核与硬件信息相关的信息。包括目前已加载的内核模块和内核侦测到的硬件装置信息。该目录不占硬盘容量
                早期Linux在发生问题时，维护模式通常仅挂载根目录，因此有五个重要的目录被要求一定要与根目录放置在一起，/etc,/bin,/dev,/lib,/sbin。目前许多Linux distributions将许多非必要文件移出/usr，从而/usr变得更为精简。/usr被建议为即使挂载成为只读，系统还是可以正常运行，所以维护模式也能同时挂载/usr。
        /usr的意义与内容
            根据FHS基本定义，/usr内放置的数据属于可分享与不可变动的，可以通过网络进行分区槽的挂载(如NFS服务器)，/usr可以分享给局域网络内的其他主机使用。
            为Unix操作系统软件资源放置的目录。FHS建议所有软件开发者，应该将数据合理分别放置到该目录下的子目录，而不是自行建立软件独立目录。类似于Windows C:\Windows\一部分+C:\Program files\的综合。
                ***FHS要求必须要存在的目录***
                /usr/bin/    所有一般用户能够使用的指令放置处。/usr/bin目前与/bin一致，全部的用户指令和使用链接文件的方式将/bin链接到此。FHS也要求此目录不应该有子目录
                /usr/lib/   与/lib功能相同，/lib链接到了此目录
                /usr/local/ 系统管理员在本机自行安装非distribution默认提供的软件，建议安装到此目录，这样便于管理。distribution提供的软件较旧，可以保留，并将新版安装至此。/usr/local下也有bin,etc,include,lib...的子目录
                /usr/sbin   非系统正常运行所需要的系统指令。最常见的就是一些网络服务器软件的服务指令(daemon)。基本功能与/sbin相似，/sbin链接到了此目录
                /usr/share  主要放置只读架构的数据文件，也包括共享文件。在该目录下放置的数据几乎不分硬件架构均可读取的数据，因为基本都是文本文件。常见子目录
                    /usr/share/man          联机帮助文件
                    /usr/share/doc          软件杂项的文件说明
                    /usr/share/zoneinfo与   时区有关的时区文件
                ***FHS建议可以存在的目录***
                /usr/games/     与游戏比较相关的数据放置处
                /usr/include/   c/c++等程序语言的头和包含文件放置位置，以tarball方式(*.tar.gz的方式安装软件)安装某系数据时，会用到里面的许多包含文件
                /usr/libexec/   某些不被一般使用者惯用的执行文件或脚本等，都会放置在此目录种。例如大部分的X窗口下的操作指令，很多放置于此。
                /usr/lib<qual>/ 与/lib<qual>/功能相同，因此目前/lib<qual>链接到了此目录
                /usr/src/       一般原始码建议放置到此，source。内核原始码建议放置到/usr/src/linux目录下
        /var的意义与内容
            如果/usr时安装时会占用较大硬盘容量的目录，/var就是系统运行后才会逐渐占用的目录。/var目录主要针对常态性变动的文件，包括缓存(cache)、日志(log file)以及某些软件运行产生的文件，包括程序文件(lock file,run file)或者例如MySQL数据库的文件
                ***FHS要求必须要存在的目录***
                /var/cache/ 应用程序本身运行过程中会产生的一些暂存文件
                /var/lib/   程序本身执行过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件有独立的目录。
                /var/lock/  某些设备或者文件资源一次只能被一个应用程序所使用，如果有两个程序使用该装置，可能会产生错误。所以将该装置上锁。
                /var/log/   日志文件放置目录。比较重要的文件
                    /var/log/messages,/var/log/wtmp(记录登入者的信息)
                /var/mail/  放置个人电子邮件信箱的目录，该目录也被放置到/var/spool/mail/目录中。通常这两个目录互为链接
                /var/run/   某些程序或者是服务启动后，会将他们的PID放置在这个目录下。与/run相同，该目录链接到了/run
                /var/spool  该目录通常放置一些队列数据，队列即排队等待其他程序使用的数据。这些数据使用后通常会被删除。
        针对FHS，不同的distribution有略微差异
    目录树
        在Linux下，所有的文件与目录都从根目录开始。
            目录树的起始点为根目录(/,root)。
            每一个目录不止能使用本地端的partition的文件系统，也可以使用网络上的filesystem。
            每一个文件在此目录树中的文件名(包含完整路径都是独一无二的)
    绝对路径与相对路径
        文件名写法不同，路径可以定义为绝对路径和相对路径
            绝对路径，由根目录开始写起
            相对路径，相对于目前路径
            .代表当前目录，或./
            ..代表上一层目录，或../
        执行文件时，例如./*.sh，表示执行当前路径下的某个*.sh
    uname -r查看内核版本，uname -m查看操作系统的位版本

## 六、Linux文件与目录管理

### 6.1 目录与路径

    相对路径与绝对路径
        相对路径对于单独环境，较长路径且跳转较小的路径较为方便
        绝对路径，对于文件名的正确性、管理系统更好
    目录的相关操作
            .       代表此层目录
            ..      代表上一层目录，根目录的此层和上一层一致
            -   前一个工作目录
            ~       代表前一个工作目录
            ~name   代表用户name的主目录
            cd      切换目录，change directory
            pwd     显示当前目录，print working directory
            mkdir   建立一个新的目录
            rmdir   删除一个空的目录
        pwd,显示当前所在目录
            pwd [-P]，-P显示出真实路径，而非链接路径
        mkdir,建立新目录
            mkdir [-mp] [xyz] dirname
                -m配置文件的权限，直接设定，不需要看预设权限(umask)
                -p将所需要的上层目录递归建立
        rmdir,删除空的目录
            rmdir [-p] dirname，-p连同上层空的目录一起递归删除，即该目录删除后上一层也变空，则一起删除
            rm -r name会将目录下的一起删除，较为危险
    关于执行文件路径的变量:$PATH
        在执行一个指令时，系统会依照PATH的设定去每个PATH定义的目录下搜索文件名名为指令名的可执行文件，如果在PATH定义的目录中含有多个文件名为指令名的可执行文件，先搜索到的同名指令先被执行
            echo $PATH，显示出path，echo显示指令，$后接变量
        每个目录中间用:隔开，不同用户的$PATH不同，WSL的初始用户PATH包含windows系统的系统环境变量PATH；无论是root还是用户都有/bin和/usr/bin，但这两个目录的内容会一致
            PATH="${PATH}:dirpath"，将一个路径添加到现有的路径
        为了安全，不会建议将.(当前路径)加入PATH的搜索目录中

### 6.2 文件与目录管理

    主要是显示属性、拷贝、删除文件以及移动文件或目录
    文件与目录的查看:ls
        ls [-aAdfFhilnrRSt] filename/dirname..
        ls [--color={never,auto,always}] filename/dirname..
        ls [--full-time] filename/dirname..
            -a 全部的文件，连同隐藏文件
            -A 全部的文件，连同隐藏文件，但不包括.和..
            -d 仅列出目录本身，而不是列出目录内的文件数据
            -f 直接列出结果，而不进行排序(ls预设会进行文件名排序)
            -F 根据文件、目录等信息，给予附加数据符号
                *表示可执行文件，/表示目录，@表示链接，|表示FIFO，=表示socket，>表示door，一般文件不加符号
            -h 将文件大小以易读的方式表示，如GB、KB，配合-l
            -i 列出inode号码
            -l 长数据串按行显示，包含文件的属性与权限等
            -n 列出UID与GID而非使用者与群组的名称(与账号管理相关)
            -r 将排序结果反序
            -R 连同子目录内容一起列出来，即该目录下的所有文件都会显示出来
            -S 以文件大小排序，而非文件名
            -t 以时间排序，而非文件名
            --color=never，不根据文件属性显示颜色
            --color=always，显示颜色
            --color=auto，让系统自行以及设定来判断是否显示颜色
            --full-time，以完整时间格式(年月日时分)输出
            --time={atime,ctime}，输出access时间(atime)或改变权限属性时间(ctime)，而非内容改变时间(modification time)
        最常用的即为-l，所以许多版本将ls -alF缩写为ll，是Bash shell的alias功能
    复制、删除与移动,cp,rm,mv
        cp可以用于复制、建立链接、比较两文件的新旧而进行更新，复制整个目录等
        mv可以用来重命名
        复制文件或目录,cp
            cp [-adfulprsu] srcfile desfile
            cp [options] src1 src2 src3 ... dirname
                -a 相当于-dr --preserve=all
                -d 若源文件为链接文件，则复制链接文件而非文件本身
                -f 强制，若目标文件已经存在且无法开启，则移除后再尝试一次
                -i 若目标文件已经存在，在覆盖时会先询问动作的进行
                -l 进行硬式链接(hard link)的链接文件建立，而非复制文件本身‘
                -p 连同文件的属性(权限、用户、时间)一起复制，而非使用默认属性
                -r 递归持续复制，用于目录的复制
                -s 复制成为符号链接文件，即快捷方式
                -u 目标比源文件旧才更新，或者目标不存在才复制
                --preserve=all 除了-p的权限相关参数外，还加入SELinux的属性，links,xattr等也复制了
            在进行备份时，需要特别注意一些特殊权限文件，例如密码以及一些配置文件，需要加上-a或者-p来完整复制文件权限。
            -s创建的是符号链接；-l创建的则是实体链接，并且会将源文件link数增加，权限与源文件一致，涉及inode
            可以将多个文件一次复制到同一个目录内
        移除文件或目录,rm
            rm [-fir] filename/dirname
                -f 忽略不存在的文件，不会出现警告信息
                -i 互动模式，在删除前会询问使用者是否动作
                -r 递归删除，非常危险
                使用通配符更为方便迅速
            在root身份下，预设加入了-i的选项。如果使用\rm ...，则会忽略掉alias的指定选项，谨慎使用。
            如果文件名前缀为-，可以使用rm -- name来，或者rm ... ./name来指定
        移动文件与目录，或重命名,mv
            mv [-fiu] source destination
            mv [options] source1 source2 ... directory
                -f 强制，如果目标文件已经存在，不会询问而直接覆盖
                -i 若目标文件已经存在，询问是否覆盖
                -u 若目标文件已经存在，只有source比较新时，才会更新
            Linux有个专门多个文件同时重命名，rename
    取得路径的文件名与名称
        basename 完整名称，获得最终文件名
        dirname 完整名称，获得目录

### 6.3 文件内容查阅

        cat     从第一行开始显示文件内容
        tac     从最后一行开始显示(cat的倒置)
        nl      显示时，输出行号
        more    按页显示文件内容
        less    与more相似，而且可以往前翻页
        head    只看头部几行
        tail    只看尾部几行
        od      以二进制的方式读取文件内容
    直接查看文件内容
        cat(concatenate)
            cat [-AbEnTv]
                -A 相当于-vET的整合选项，可以列出一些特殊字符而不是空白
                -b 列出行号，仅针对非空白行做行号显示，空白行不标行号
                -E 将结尾的断行字符$显示出来
                -n 打印出行号，连同空白行也会有行号
                -T 将tab制表符用^I显示出来
                -v 列出一些看不出来的特殊字符
            windows的断行字符是^M$
        tac为cat的反向显示
        添加行号打印，nl
            nl [-bnw] filename
                -b 指定行号显示的方式
                    -b a 不论是否为空行，同样列出行号
                    -b t 如果有空行，空的那一行不列出行号(默认)
                -n 列出行号表示的方法
                    -n ln 行号左对齐显示
                    -n rn 右对齐，且不加0
                    -n rz 右对齐，且加0，还可以接-w n——表示自动补齐0的个数
    可翻页查看
        一页页翻动，more
            最后一行会显示出目前显示的百分比
                空格键   向下翻页
                Enter   向下翻一行
                /字符串  向下搜索字符串
                :f      立刻显示出文件名以及目前显示的行数
                q       退出more
                b或者ctrl-b 往回翻页，只对文件有用，对pipes无用
        less
            拥有更多搜索功能
                空格键/PageDown  向下翻页
                PageUp  向上翻页
                /字符串 向下搜索字符串
                ?字符串 向上搜索字符串
                n       重复前一个搜索
                N       反向的重复前一个搜索
                g       跳转到文件的第一行
                G       跳转到文件的最后一行
                q       退出less
            man是通过调用less来显示man page的
    文本提取
        head与tail都是以行为单位进行的
        取出前面几行，head
            head [-n number] filename，默认显示十行
                number为负数时，表示不显示后面几行
        取出后面几行，tail
            tail [-n number] filename
                -f 持续检测后面所接的文件名，直到按下ctrl-c才会结束检测，新加入的数据都会被显示
        特殊使用
            head -n 20 filename | tail -n 10，pipe的使用，前面指令所输出的信息，通过pipe传递给后续的指令继续使用，从而前一个指令不会输出
    非纯文本文件:od
        od [-t TYPE] filename
            -t 可以接各种类型的输出
                a       使用默认的字符来输出
                c       使用ASCII字符来输出
                d[size] 使用十进制来输出数据，每个整数占用size bytes
                f[size] 使用浮点数来输出数据，每个数占用size bytes
                o[size] 使用八进制来输出数据，每个整数占用size bytes
                x[size] 使用十六进制来输出数据，每个整数占用size bytes
                oCc，表示，按照八进制显示，并且用sizeof(char)来分隔，并且同时以字符显示，还有type [doux]:C、Short、Int、Long;type;[f]:Float、Double、Long double
            还会显示出字节数
    修改文件时间或新建文件,touch
        修改时间(mtime):当文件的内容变化时会更新，不是属性或权限变化
        状态时间(ctime):当文件的状态变化时会更新，例如属性和权限
        访问时间(atime):当文件的内容被访问时，例如cat
        在默认情况下ls显示出来的是该文件的mtime。
        touch [-acdmt] filename
            -a 仅修改atime
            -c 仅修改文件的时间，若文件不存在则不建立新文件
            -d 可以接想要修改的日期而不用目前的时间，或者--date="日期或时间"，例如"2 days ago"
            -m 仅修改mtime
            -t 后面可以接想要修改的时间而不用目前的时间，格式[YYYYMMDDhhmm]，例如201406150202

### 6.4 文件与目录的默认权限与隐藏权限

    除了基本的rwx权限外，在Linux传统的Ext2/Ext3/Ext4文件系统下，还可以设定其他的系统隐藏属性，这部分可使用chattr来设定，用lsattr来查看，最重要的属性就是设定其不可修改的属性。让文件拥有者也不能修改。xfs没有支持全部的chattr参数，仅有部分参数能够支持
    文件预设权限,umask
        指定目前用户在建立文件或目录时的权限默认值
            umask，显示数字形态的权限设定分数，0有效，八进制，第一个为特殊权限
                -S 以符号类型显示权限
                xyz 修改umask
                新建文件时，权限为-rw-rw-rw- - -----w--w- = -rw-r--r--
                新建目录时，权限为drwxrwxrwx - d----w--w- = drwxr-xr-x
        umask的利用与重要性
            相同群组的状态，可能另一名用户无法编辑一名用户建立的文件
            特别是在服务器上，例如SAMBA Server和FTP Server
        umask的计算中，如果用数字相减，需要注意只有对应位有1才会被减，否则会出错，例如6-3=3
        一般情况下，root的umask默认为022，一般用户为002，保留同群组的写入能力。 关于umask的设定可以参考/etc/bashrc
    文件隐藏属性
        配置文件隐藏属性
            chattr [+-=][ASacdistu] filename/dirname
                + 增加某一个特殊参数，原本存在参数不动
                - 移除某一个特殊参数，原本存在参数不动
                = 设定唯一参数，原本存在参数移除
                A 设定后存取文件或目录时，访问时间不会被修改，避免I/O较慢的机器过度的存取磁盘(建议使用文件系统挂载参数处理)
                S 一般文件是异步写入磁盘的，设定后进行任何文件的修改，修改会同步写入到磁盘中
                a 设定后只能增加数据，不能删除也不能修改数据，只有root才能设定
                c 设定后会自动的将文件压缩，在读取的时候会自动解压。在存储的时候，将会先进行压缩再储存
                d 当dump程序被执行时，设定后可使该文件或目录不会被dump备份
                i 设定后让一个文件不能被删除、改名、设定链接、无法写入或新增数据。只有root才能设定
                s 设定后如果该文件被删除，将会完全地从硬盘空间移除，无法恢复
                u 与s相反，设定后文件如果被删除，数据内容还在磁盘中，可以被恢复
                xfs文件系统仅支持AadiS
        显示文件隐藏属性
            lsattr [-adR] filename/dirname
                -a 将隐藏文件属性也列出来
                -d 如果接的是目录，仅列出目录本身的属性而非目录内的文件名
                -R 连同子目录的数据也一起列出
    文件的特殊权限:SUID，SGID，SBIT
        特殊权限s和t与系统的账号、系统的程序有关
        Set UID
            当标志s出现在文件拥有者的x权限上时，被称为Set UID，简称SUID的特殊权限。SUID的限制与功能
                SUID权限仅对二进制程序有效
                执行者对于该程序需要具有x的可执行权限
                本权限仅在执行该程序的过程中有效
                执行者将具有该程序拥有者的权限
            可以让用户在执行过程中暂时获得拥有者的权限
            SUID仅可用在二进制程序上，不能用在shell script上
        Set GID
            当标志s出现在群组的x权限上时，被称为Set GID
            SGID可以针对文件或目录来设定，对于文件
                SGID对二进制程序有用
                程序执行者对于该程序来说，需要具备x的权限
                执行者在执行的过程中将会获得该程序群组的支持
            SGID也能用在目录上，当一个目录设定了SGID权限后
                用户若对于此目录具有rx权限时，该用户能够进入此目录
                用户在此目录下的有效群组将会变成该目录的群组
                用途：若用户在此目录下具有w的权限(可以新建文件)，则使用者所建立的新文件的群组与此目录的群组相同
        Sticky Bit
            SBIT目前只针对目录有效，对于文件没有作用。t出现在在其他人的x权限上
                当用户对此目录具有w，x权限，即具有写入的权限时
                当用户在该目录下建立文件或目录时，仅有自己和root才有权力删除该文件
                若目录加上了SBIT的权限项目时，用户只能针对自己建立的文件或目录进行删除/重命名/移动等动作，而无法删除他人的文件
        SUID/SGID/SBIT权限设定
            chmod数字形态更改权限方式，第一个八进制数设置，SUID/SGID/SBIT
            符号法：u=rwxs，或者g+s,o+t
            如果显示的是大写S和T，表示文件拥有者本身不具有权限，实际无效。
    观察文件类型：file
        可以通过file指令来查看文件的基本数据，例如ASCII还是data、二进制，是否使用到了动态函数库(share library,windows为dll)
        file /usr/bin/passwd能够得到
            setuid ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=省略, for GNU/Linux 3.2.0, stripped
            既包括执行文件的数据：suid权限、兼容于Intel x86-64等级的硬件平台、使用的是Linux内核的动态函数库链接

### 6.5 指令与文件的搜寻

    有些软件配置文件的文件名不变，但个版本放置的目录不同。可以通过一些搜索指令将该配置文件的完整文件文件名提取出来
    脚本文件名的搜索
        寻找执行文件，which
            which [-a] command
                -a 将所有PATH目录中可以找到的指令均列出，而不止第一个被找到的指令名称
            如果列出了多个，并且有叫做alias的，属于指令别名，即输入该指令会等于后面接的指令，指令alias可以查看更多
            对于指令history，属于bash内建指令，无法被找到，可以通过type查看
    文件名的搜索
        一般不使用find，速度较慢且对硬件占用较多。一般先使用whereis或者locate来查找。whereis只搜索系统中某些特定目录下的文件，locate利用数据库来搜索文件名，都没有实际的搜索硬盘内的文件系统状态。
        由一些特定的目录中搜索文件名，whereis
            whereis [-bmsu] filename/dirname
                -l 列出whereis会去查询的几个主要目录
                -b 只搜索二进制格式的文件
                -m 只搜索在说明manual路径下的文件
                -s 只搜索source来源文件
                -u 搜索不在上述三个项目当中的其他特殊文件
        locate/updatedb
            locate [-ir] keyword
                -i 忽略大小写的差异
                -c 不输出文件名，仅计算找到的文件数量
                -l 仅输出几行，后接数字，非正数无效
                -S 输出locate所使用的数据库文件的相关信息，包括该数据库记录的文件/目录数量等
                -r 后面可接正规表示法的显示方式
            locate基于数据库来搜索，数据库的建立默认是每天执行一次，新建立起来的文件，需要在数据库更新之后再搜索
            updatedb，根据/etc/updatedb.conf的设定去搜索系统硬盘内的文件名，并更细/var/lib/mlocate内的数据库文件
            locate，依据/var/lib/mlocate内的数据库记载，找出用户输入的关键词文件名
        find
            find [PATH] [option] [action]
              与时间有关的选项，-atime -ctime -mtime，用法相似
                -mtime n  在n天之前的当天内被改动过内容的文件
                -mtime +n 列出在n天之前(不含n天本身)被改动过内容的文件名
                -mtime -n 列出在n天之内(含n天本身)被改动过内容的文件名
                -newer filename 列出比filename还要新的文件名
              与使用者或者组名有关的参数
                -uid n n为用户的账号ID(UID)，UID为记录在/etc/passwd内与账号名称对应的数字
                -gid n      n为组名的ID(GID)，记录在/etc/group
                -user name  name为使用者账号名称
                -group name name为组名
                -nouser     寻找文件的拥有者不存在/etc/passwd
                -nogroup    寻找文件的拥有群组不存在于/etc/group的文件，当自行安装软件时，很可能该软件的属性中没有文件拥有者。或者将系统里某个账号删除了，但该账号已经在系统内建立了很多文件，-nouser也适用
              与文件权限及名称有关的参数
                -name filename  搜索文件名为filename的文件，可以使用通配符，如'*httpd*'
                -size [+-]SIZE  搜索比SIZE要大(+)或小(-)的文件。size的规格，c表示byte，k表示1024bytes。
                -type TYPE      搜索文件的类型为TYPE的，类型主要有：一般常规文件(f)，设备文件(b,c)，目录(d)，链接文件(l)，socket(s)、FIFO(p)等
                -perm mode      搜索文件权限为mode的文件，mode与chmod的格式一致
                -perm -mode     搜索文件权限包括mode的文件，即权限码与mode逻辑与后为mode
                -perm /mode     搜索文件权限包括任意mode的文件，即权限码与mode逻辑与后为权限码
              额外可进行的操作
                -exec command   可再接额外的指令来处理搜寻到的结果，不能使用alias指令
                -print          将结果输出，为预设操作
            find能够搜索子目录
                find /usr/bin -perm /7000 -exec ls -l {} \;
                    {}表示由find找到的内容
                    -exec直到\;为关键词，表示额外动作的开始到结束
                    ;在bash环境下有特殊意义，所以用\转义

## 七、Linux磁盘与文件系统管理

### 7.1 认识Linux文件系统

    Linux最传统的磁盘文件系统使用的是EXT2
    文件系统特性
        磁盘分区完毕后还需要进行格式化，然后操作系统才能使用这个文件系统。格式化的原因，是因为每种操作系统所设定的文件属性/权限并不相同。
        每种操作系统能够使用的文件系统并不相同。win98以前的微软操作系统主要使用FAT(或FAT16)，win2000以后的版本有NTFS，Linux的正统文件系统为Ext2(Linux Second extended file system, ext2fs)。默认情况下，windows操作系统无法识别Ext2
        传统的磁盘与文件系统的应用中，一个分区槽只能被格式化为一个文件系统，一个filesystem就是一个partition。现在的LVM与软件磁盘整列(software raid)，可以将一个分区槽格式化为多个文件系统(如LVM)，也能够将多个分区槽合并成一个文件系统(LVM,RAID)。目前在格式化时不在说成针对partition来格式化，而可以称一个可被挂载的数据为一个文件系统而不是分区槽
        文件系统运行于操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外，通常含有非常多的属性，例如Linux操作系统的文件权限rwx与文件属性(拥有者与群组、时间参数等)。文件系统通常会将这两部分的数据分别存放在不同的区块，权限与属性放在inode中，实际数据放在data block区块中。还有一个超级区块(superblock)记录整个文件系统的整体信息，包括inode与block的总量、使用量、剩余量等
        每个inode与block都有编号。一个文件占用一个inode，同时记录此文件的数据所在的block号码，效率较高。一个文件如果太大，会占用多个block。
        上述数据存储的方法称为索引式文件系统。闪存使用的文件系统一般为FAT格式，不存在inode，每个block都记录在前一个block中，所以磁盘会需要多次循环才能完整读取。
        所以FAT需要进行碎片整理，因为文件写入的block过于离散，读取的效率会变低。通过碎片整理可以将同一个文件所属的blocks整理在一起。
        Ext2是索引式文件系统，不太需要碎片整理。但如果文件系统使用太久，常常删除/编辑/新增文件时，可能会造成文件数据太过于离散，可以进行碎片整理
    Linux的EXT2文件系统(inode)
        标准的Linux文件系统Ext2使用以inode为基础的文件系统
        文件系统一开始就将inode和block规划好了，除非重新格式化(或者用resize2fs等指令变更文件系统大小)，否则inode与block固定后就不再变动。
        Ext2文件系统在格式化时基本上是区分为多个区块群组，每个区块群组都有独立的inode/block/superblock系统。
        在整体的规划当中，文件系统最前面有一个启动扇区，这个启动扇区可以安装开机管理程序，从而能够将不同的开机管理程序安装到个别的文件系统最前面，而不用覆盖整颗磁盘唯一的MBR，进而配置多重引导的环境。每个区块群组的六个主要内容
            data block(资料区块)
                用来放置文件内容数据，在Ext2文件系统中所持的block大小有1K,2K,4K三种。在格式化时固定block的大小，且每个block都有编号。不同block大小对应不同的文件系统能够支持的最大磁盘容量与最大单一文件容量。
                    Block大小           1KB     2KB     4KB
                    最大单一文件限制     16GB    256GB   2TB
                    最大文件系统总容量   2TB     8TB     16TB
                虽然Ext2能够支持大于2GB以上的单一文件容量，但是某些应用程序依然使用旧的限制，即某些程序只能使用小于2GB的文件。其他的基本限制
                    block的大小与数量在格式化完成后不能够再改变(除非重新格式化)
                    每个block内最多只能放置一个文件的数据
                    如果文件大于block的大小，则一个文件会占用多个block
                    若文件小于block，则该block的剩余容量不能够再使用(浪费)
                block较小，大型文件会占用较多的block，inode需要记录更多的block号码，导致文件系统读写效率较差；block较大，会产生更多的磁盘容量浪费
            inode table(inode表格)
                inode记录的文件数据至少有
                    该文件的存取模式、拥有者与群组、容量
                    该文件建立或状态改变的时间(ctime)、atime、mtime
                    定义文件特性的标志，如SUID...
                    该文件真正内容的指针
                inode的其他特性
                    每个inode大小均固定为128bytes(新的ext4与xfs可设定到256bytes)
                    每个文件仅会占用一个inode
                    文件系统能够建立的文件数量与inode有关‘
                    系统读取文件时需要先找到inode，并分析inode所记录的权限与用户是否符合，若符合才能开始实际读取block的内容
                系统将inode记录block号码的区域定义为12个直接，1个间接，1个双间接，1个三间接。直接区能够直接取得block号码，间接是再拿一个block来当作记录block号码的记录区，如果文件太大，会使用间接的block来记录编号。实际记录则在最后一层block
                当文件系统将block格式化为1K大小时，能够容纳的大小与文件系统先指标的结果是一致的，但是在更大的block中，会受到Ext2文件系统本身的限制。
                Ext4文件系统的inode容量扩大到256bytes，更大的inode容量，可以记录更多的文件系统信息，包括新的ACL和SELinux类型等。可以记录的单一文件容量达16TB且单一文件系统总容量可达1EB
            superblock(超级区块)
                Superblock是记录整个filesystem相关信息的地方，记录的信息
                    block与inode的总量
                    未使用与已使用的inode/block数量
                    block与inode的大小(block为1,2,4K,inode为128bytes或256bytes)
                    filesystem的挂载时间、最后一次写入数据的时间、最近一次检验磁盘(fsck)的时间等文件系统的相关信息
                    一个valid bit，若此文件系统已被挂载，则valid bit为0，否则为1
                一般superblock大小为1024bytes，可以通过dumpe2fs查看
                每个block group都可能有superblock。一个文件系统应该只有一个superblock。除了第一个block group内含有superblock，后续的为备份
            Filesystem Description(文件系统描述说明)
                这个区段描述每个block group开始与结束的block号码，以及说明每个区段(superblock,bitmap,inodemap,data block)分别位于哪一个block号码之间。也能够用dumpe2fs查看
            block bitmap(区块对照表)
                新增文件时会用到block，使用空的block进行记录。从block bitmap获取block是否空的状态，从而系统能够快速找到可以使用的空间来处理文件
                删除一些文件时，原本占用的block号码便得到释放，在block bitmap中对应的标志修改为空
            inode bitmap(inode对照表)
                与block bitmap功能类似，inode bitmap记录使用与未使用的inode号码
            dumpe2fs
                查询Ext系列superblock信息的指令
                以xfs为预设文件系统的，无法使用dumpe2fs查询
                dumpe2fs [-bh] 设备文件名
                    -b 列出保留为坏轨(逻辑坏轨、物理硬盘坏轨)
                    -h 仅列出superblock的数据，不会列出其他的区段内容
                blkid，列出目前系统有被格式化的装置
                对于一个ext4，dumpe2fs可以获取到
                    Filesystem volume name  文件系统的名称(不一定会有)
                    Last mounted on         上一次挂载的位置
                    Filesystem UUID         Linux对装置的定义码
                    Filesystem features     文件系统的特征数据
                    Default mount options user_xattr acl    预设在挂载时会主动加上的挂载参数
                    Filesystem state        文件系统的状态，clean为无问题
                    Inode count             inode的总数
                    Block count             block的总数
                    Reserved block count    保留的block总数
                    Free blocks             剩余的block可用数量
                    Free inodes             剩余的inode可用数量
                    Block size              单个block的容量大小
                    Inode size              inode的容量大小
                    Journal size            Journal日志式数据的可供记录总量
                    Group n                 第n块block group位置
                        主要superblock所在(n=0)，inode table所在，剩余的容量
    与目录树的关系
        目录
            当在Linux下的文件系统建立一个目录时，系统文件会分配一个inode与至少一块block给该目录。其中inode记录该目录的相关权限与属性，并可记录分配到的block号码；block记录在这个目录下的文件名与该文件名占用的inode号码。
            使用ls -i查看inode号码，目录的大小几乎都是1024的倍数。可用看见/proc和/sys占用block为0
        文件
            在Linux下的ext2新建一个一般文件时，ext2会分配一个inode与相对于该文件大小的block数量给该文件，注意直接与二三间接
        目录树读取
            需要读取某个文件时，会经过目录的inode与block，然后才能够找到那个待读取文件的inode号码，进而读取到数据
            目录树从根目录开始读起，系统通过挂载的信息可以找到挂载点的inode，得到根目录的inode内容，进而读取根目录block内的文件名数据
        filesystem大小与磁盘读取效率
            如果文件写入的block分的很散，文件数据离散的问题便会发生。磁盘读取需要在整个文件系统频繁读取。可以将整个filesystem内的数据全部复制，将filesystem重新格式化，再将数据复制回去
            当一个文件分别记录在这个文件系统的最前面与最后面的block中，会造成磁盘的机械手臂移动幅度过大，导致数据读取效率变低。所以partition并不是越大越好
    EXT2/EXT3/EXT4文件的存取与日志式文件系统的功能
        新建一个文件或目录时
            先确定用户对于要新建文件的目录是否具有w与x的权限，有才能新建
            根据inode bitmap找到没有使用的inode号码，并将新文件的权限/属性写入
            根据block bitmap找到没有使用的block号码，并将实际的数据写入block中，更新inode的block指针数据
            将刚刚写入的inode与block数据同步更新inode bitmap与block bitmap，并更新superblock内容
        一般将inode table和data block称为数据存放区域，其他例如superblock、block bitmap和inode bitmap等区域称为metadata(中介数据)。每次新增、删除、编辑时都可能会影响到中介数据
        数据的不一致状态
            在一般正常的情况下，新增、删除、编辑操作都可以顺利完成。但如果发生系统中断，使得操作未完成，就会出现数据不一致。
            早期的Ext2文件系统如果发生问题，系统在重新启动时，会通过Superblock中记录的valid bit和filesystem state等状态来判断是否强制进行数据一致性的检查。检查通过程序e2fsck，较为费时
        日志式文件系统
            为了避免文件系统不一致的情况发生，设计者在filesystem中划出一个区块啊，专门记录在写入或修改文件时的步骤
                预备：当系统要写入一个文件时，会先在日志记录区块中记录某个文件准要要写入的信息
                实际写入：开始写入文件的权限与数据；开始更新metadata的数据
                结束：完成数据与metadata的更新后，在日志记录区块当中完成该文件的记录
            数据的记录过程中如果发生了问题，系统只需要检查日志记录区块，从而针对该问题做一致性检查
            ext3/ext4为ext2的升级版本，并且可以向下兼容ext2版本，并实现日志式管理。dumpe2fs的superblock有关于Journal日志的信息
    文件系统的运行
        为了解决磁盘写入的速度比内存慢，Linux使用了异步处理的方式
        当系统加载一个文件到内存后，如果该文件没有被修改过，在内存区段的文件数据会被设定为clean。但如果内存中的文件数据被修改过，该内存中的数据会被设定为dirty。系统会不定时的将内存中设定为Dirty的数据写回磁盘，以保持磁盘与内存数据的一致性。或者可以使用sync来手动强迫写入磁盘
            系统会将常用的文件数据放置到主存储器的缓冲区，以加速文件系统的读/写
            Linux的物理内存最后都会被用完，可以加速系统效率
            可以手动使用sync来强迫内存中设定为dirty的文件写回到磁盘中
            正常关机时，关机指令会主动呼叫sync来将内存的数据回写入磁盘内
            但如果不正常关机(如跳电、宕机等)，由于数据尚未会写到磁盘内，重新启动后可能会进行磁盘检验，也可能导致文件系统的损毁(非磁盘损毁)
    挂载点的意义(mount point)
        每个filesystem都有独立的inode/block/superblock等信息，文件系统要能链接到目录树才能被使用。将文件系统与目录树结合的操作称为挂载。挂载点一定是目录，该目录为进入该文件系统的入口。并不是任何文件系统都能使用，必须要挂载到目录树的某个目录后，才能够使用该文件系统
        XFS filesystem最顶层的目录的inode一般为128。/,/boot,/home为三个不同的filesystem(因为文件属性、挂载点不同)。而/,/.,/..为同一filesystem。
    其他Linux支持的文件系统与VFS
        Linux还支持除了ext2/ext3/ext4外的文件系统格式。包括SGI的XFS文件系统，可以适用更小型文件的Reiserfs文件系统，以及Windows的FAT文件系统等。常见的支持文件系统
            传统文件系统：ext2/minix/MS-DOS/FAT(vfat模块)/iso9660(光盘)等
            日志式文件系统：ext3/ext4/ReiserFS/Windows'NTFS/IBM's JFS/SGI's XFS/ZFS
            网络文件系统：NFS/SMBFS
        ls -l /lib/modules/$(uname -r)/kernel/fs，查看Linux支持的文件系统
        cat /proc/filesystems，查看系统目前已加载到内存中支持的文件系统
        Linux VFS(Virtual Filesystem Switch)
            整个Linux系统通过VFS的内核功能来读取filesystem，并不需要知道每个partition上的filesystem。
            用户程序->系统调用界面(内核提供)->VFS->filesystem->缓存->设备驱动程序->磁盘设备控制器
    XFS文件系统
        EXT系列问题：支持度最广，但是格式化速度慢
            Ext文件系统系列对于文件格式化的处理，首先是预先规划出所有的inode/block/meta data等数据，未来系统可以直接取用，不需要进行动态配置。当TB以上的传统ext系列格式化时，需要消耗较多时间
            作为虚拟化磁盘来源的大型文件变得常见，在处理上需要考虑效率问题
        XFS文件系统的配置
            xfs就是一个日志式文件系统，较早时期，被开发用于高容量磁盘与高性能文件系统，适合于现有的系统环境。xfs几乎具备Ext4文件系统所有的功能。
            在数据的分布上，主要规划为，数据区、文件系统活动登录区、实时运行区
            数据区
                包括inode/data block/superblock等数据，分为多个存储区群组来分别放置文件系统所需的数据。每个存储区群组包含：整个文件系统的superblock、剩余空间的管理机制、inode的分配与追踪。inode和block都是系统需要用到时，才会动态配置产生，故格式化速度块
                与ext系列不同，xfs的block与inode有多种不同的容量可以设定，block可以在512bytes-64K之间，Linux环境下，由于内存控制的原因(pagesize容量)，最高可以使用的block大小为4K，大于4K可以格式化，但是Linux内核无法挂载。inode容量在256bytes-2M之间。
            文件系统活动登录区
                在登录区主要用来记录文件系统的变化，类似于日志区。文件的修改会在这里记录，直到该变化完整地写入到数据区后，该笔记录才会结束。可以用于数据一致性检验
                系统所有操作都会在这个区块记录，所以磁盘活动较为频繁。xfs的这个区域，可以指定外部的磁盘来作为xfs文件系统的日志区块。
            实时运行区
                当要新建文件时，xfs会在这个区段寻找1到多个的extent区块，将文件放置在这个区块内，等到分配完毕后，再写入到数据区的inode和block中。extent区块的大小在格式化时指定，范围为4K-1G。一般非磁盘阵列的磁盘默认为64K，具有类似磁盘阵列的stripe情况下，建议extent设定为与stripe一样大小。extent会影响到实际磁盘效率
        XFS文件系统的描述数据查看
            xfs_info 挂载点|装置文件名
            df -T /boot，找出/boot这个挂载点下的文件系统superblock记录
            xfs_info可以获得，inode容量、逻辑扇区大小、block容量、extent容量

### 7.2 文件系统的简单操作

    磁盘与目录的容量
        列出文件系统的整体磁盘使用量，df
            df [-ahikHTm] [filename/dirname]
                -a 列出所有的文件系统，包括系统特有的/proc等文件系统
                -k 以KBytes的容量显示各文件系统
                -m 以MBytes的容量显示各文件系统
                -h 以易阅读的GBytes、MBytes、KBytes等格式自行显示
                -H 以M=1000K取代M=1024K的进位方式
                -T 连同该partition的filesystem名称(例如xfs)
                -i 不用磁盘容量，而以inode的数量显示
            df不加参数，能够列出所有的filesystem，输出
                Filesystem：代表该文件系统所在partition，列出设备名称
                1K-blocks：说明底下的数字单位为1KB，用-h和-m改变显示
                Used：已使用的磁盘空间
                Available：剩余的磁盘空间
                Use%：磁盘使用率
                Mounted on：磁盘挂载的目录
            df主要读取的数据是针对整个文件系统，读取的范围主要是Superblock内的信息。
            /dev/shm/，是利用内存虚拟出来的磁盘空间，所以总是占物理内存的一半。在这个目录下建立任何数据文件时，访问速度非常快，但是关机即丢失
        评估文件系统的磁盘使用量，du
            du [-ahskm] filename/dirname
                -a 列出所有的文件与目录容量，默认仅统计目录底下的文件量
                -h 以易读的容量格式显示
                -s 列出总量，而不显示单个目录占用容量
                -S 不包括子目录下的统计
                -k 以KBytes列出容量
                -m 以MBytes列出容量
            du不加任何选项时，会分析目前所在目录的文件与目录所占用的磁盘空间。实际显示时，只会显示目录容量(不含文件)，大小单位为1K
            du会直接到文件系统内搜寻所有的文件数据。
    实体链接与符号链接，ln
        Linux的链接文件有两种，一种是快速链接到目标文件(或目录)，另一种是通过文件系统的inode链接来产生新文件名，而不是新文件
        Hard Link(实体链接，硬式链接或实际链接)
            文件名只与目录有关，但是文件内容与inode有关。hard link会出现多个文件名对应到同一个inode号码。hard link只是在某个目录下新增一个文件名链接到某inode号码的关联记录
                ln oldname newname，建立实体链接
            ls结果中的链接属性，表示链接到该inode号码的文件名数
            如果将任何一个文件名删除，inode和block仍然存在
            hard link通常不会增加inode和占用block
            hard link只能在单一文件系统，限制
                不能跨filesystem，不能link目录
            不能链接目录是因为，链接到目录时，链接的数据需要连同被链接目录底下的所有数据都建立链接。如果在一个目录建立新文件，另一个目录需要重新hard link
        Symbolic Link(符号链接，快捷方式)
            建立一个独立的文件，而这个文件会让数据的读取指向它link的那个文件的文件名。只是利用文件来作为指向的操作，当来源文件被删除后，symbolic link文件会无法打开
                ln -s oldname newname，建立符号链接
            两个文件指向不同的inode，符号链接文件大小与源文件文件名大小有关
            符号链接文件会占用inode和block
            ln [-sf] srcfile desfile
                -s 如果不加任何参数就进行链接，即为hard link；-s为symbolic link
                -f 如果目标文件存在，主动将文件目标直接移除后再建立
        关于目录的link数量
            建立一个新目录时，新的目录的link数为2，上层目录的link数+1

### 7.3 磁盘的分区、格式化、检验与挂载

    在系统内新增一颗磁盘时，进行的操作
        对磁盘进行分区，以建立可用的partition
        对该partition进行格式化，以建立系统可用的filesystem
        还可以对建立好的filesystem进行检验
        在Linux系统上，需要建立挂载点(也是目录)，并将其挂载
    可能还需要考虑磁盘分区槽大小，是否加入日志，inode与block的数量等
    观察磁盘分区状态
        磁盘分区主要有MBR和GPT两种格式，这两种格式所使用的分区工具不一样。但是parted均支持，但习惯于fdisk或gdisk来处理分区
        lsblk，列出系统上的所有磁盘列表
            lsblk [-dfimpt] [device]
                -d 仅列出磁盘本身，不列出磁盘的分区数据
                -f 同时列出该磁盘内的文件系统名称
                -i 使用ASCII的线段输出，不使用复杂编码
                -m 同时输出该设备在/dev底下的权限数据(rwx)
                -p 列出该设备的完整文件名
                -t 列出该磁盘设备的详细数据，包括磁盘队列机制、预读写的数据量大小
            默认输出信息
                NAME    装置的文件名，省略前导目录
                MAJ:MIN 内核通过这个来识别设备，主要:次要设备代码
                RM      是否为可卸载设备，如光盘、USB磁盘等
                SIZE    容量
                RO      是否为只读装置
                TYPE    类型：磁盘、分区槽、只读存储器
                MOUNTPOINT  挂载点
        blkid，列出设备的UUID等参数
            UUID是全局唯一标识符(universally unique identifier)，Linux会将系统内所有的装置都给予一个唯一的标识符
            能够列出设备名称、UUID、文件系统类型
        parted，列出磁盘的分区表类型与分区信息
            parted device_name print
                输出，磁盘的模块名称、总容量、每个逻辑/物理扇区容量，分区表的格式
    磁盘分区：gdisk/fdisk
        MBR分区表使用fdisk分区，GPT分区表使用gdisk分区，否则会分区失败
        gdisk内部指令
            b back up GPT data to a file
            c change a partition's name
            d delete a partition           # 删除一个分区
            i show detailed information on a partition
            l list known partition types
            n add a new partition          # 增加一个分区
            o create a new empty GUID partition table (GPT)
            p print the partition table    # 印出分区表 (常用)
            q quit without saving changes  # 不储存分区就直接离开 gdisk
            r recovery and transformation options (experts only)
            s sort partitions
            t change a partition's type code
            v verify disk
            w write table to disk and exit # 储存分区操作后离开 gdisk
            x extra functionality (experts only)
            ? print this menu
        指令p输出信息
            Number          分区槽编号
            Start(sector)   每一个分区槽开始扇区号码位置
            End(sector)     每一个分区槽结束扇区号码位置
            SIze            分区槽容量
            Code            在分区槽内可能的文件系统类型。Linux8300，swap8200，但只是用于提示
            Name            文件系统的名称
        整部磁盘可以进行额外的分区
        分区槽设计中，新分区通常选用上一个分区的结束扇区号码+1作为起始扇区号码
        只有root才能执行，设备文件名不用加数据，是针对整个磁盘设别
        用gdisk新增分区槽
            gdisk device，使用n新建，可以设定分区号码、第一个扇区起始、以及最后一个扇区结束(可以使用增量，如+1G)，GUID默认为8300，然后w保存确认
            分区表更新需要通过重新启动或者partprobe
        partprobe更新Linux内核的分区表信息
            partprobe [-s]，-s列出信息
            然后即可通过lsblk和cat /proc/partitions查看
        用gdisk删除一个分区槽
            gdisk中用d删除分区槽
            不要去处理一个正在使用中的分区槽，需要先卸载分区槽，否则无法更新分区表信息
        fdisk
            二者使用方式几乎一样，只是提示指令不同。fdisk有时会使用磁柱作为分区的最小单位。MBR分区有限制(Primary,Extended,Logical...)
            内部指令
                a toggle a bootable flag
                b edit bsd disklabel
                c toggle the dos compatibility flag
                d delete a partition            <==删除一个 partition
                l list known partition types
                m print this menu
                n add a new partition           <==新增一个 partition
                o create a new empty DOS partition table
                p print the partition table     <==在屏幕上显示分区表
                q quit without saving changes   <==不储存离开 fdisk 程序
                s create a new empty Sun disklabel
                t change a partition's system id
                u change display/entry units
                v verify the partition table
                w write table to disk and exit  <==将刚刚的动作写入分区
                x extra functionality (experts only)
    磁盘格式化(配置文件系统)
        分区后需要对文件系统进行格式化，格式化指令mkfs(make filesystem)，为综合指令，会调用正确的文件系统格式化工具软件
        XFS文件系统，mkfs.xfs
            mkfs.xfs [-b size] [-d parms] [-i parms] [-l parms] [-L label] [-f] \ [-r parms] device
                单位默认为bytes，单位s为sector个数
                -b 接block容量，512-64K，Linux最大容量限制为4K
                -d 接data section的相关参数
                    agcount=数值    设定存储群组AG数量，通常与CPU有关
                    agsize=数值     每个AG的容量，agcount和agsize设定一个即可
                    file            格式化设备为文件而非设备，例如虚拟磁盘
                    size=数值       data section容量，可以不将全部的设备容量用完
                    su=数值         当有RAID时，stripe数值，与sw搭配
                    sw=数值         当有RAID时，用于存储数据的磁盘数量(需要减去备份盘与备用盘)
                    sunit=数值      与su相当，单位为512bytes(即sector大小)
                    swidth=数值     su*sw，以512bytes为单位
                -f 如果设备内已经有文件系统，进行强制格式化
                -i 与inode相关的设定
                    size=数值       256bytes-2K，一般256便足够
                    internal=[0|1]  log设备是否内建，1表示是。如果用外部设备，取0，且需要额外设定
                    logdev=device   log设备为所接的设备，internal需要为0
                    size=数值       指定登录区的大小，一般不小于512个block，大约>2M
                -L 接文件系统的标头名称Label name
                -r 指定realtime section的相关设定值
                    extsize=数值    extent数值，一般不设定，但有RAID时，最好与swidth相同，4K-1G
                注意单位
        XFS文件系统for RAID效率优化(Optional)
            关于进阶文件系统的设定，其中有磁盘阵列。磁盘阵列为多颗磁盘组成的一颗大磁盘，利用同步写入到磁盘的技术，可以加快读写速度，并且在某一颗磁盘坏掉时，整个文件系统仍然能够持续运行(容错)
            磁盘阵列(RAID)通过将文件细分为多个小型的分区区块(stripe)后，将众多的stripes分别放到磁盘阵列里的每个磁盘。为了文件的可靠，在这些磁盘里面，会保留数个(与磁盘阵列的规划有关)备份磁盘(parity disk)，以及可能会保留一个以上的备用磁盘(spare disk)，这些区块基本上会占用磁盘阵列的总容量。‘
            分区区块的大小大多在4K-1M，与磁盘阵列卡支持的项目有关。stripe与文件数据大小以及效率相关性较高。当系统大多数是大型文件时，建议stripe大一点，从而读/写频率降低。当小文件较多时，stripe建议在64K。
            文件系统的读写性能要能够有优化，最好能够搭配磁盘阵列的参数来设计。可以先在文件系统将stripe规划好，交给RAID存取时，就不需要重复stripe过程。
        EXT4文件系统mkfs.ext4
            mkfs.ext4 [-b size] [-L label] device
                -b 设定block大小，1K、2K、4K
                -L 接设备标头名称
        其他文件系统mkfs
            mkfs.btrfs  mkfs.cramfs mkfs.ext2   mkfs.ext3   mkfs.ext4
            mkfs.fat    mkfs.minix  mkfs.msdos  mkfs.vfat   mkfs.xfs
            mkfs -t format device，将一个分区转换为其他格式
    文件系统检验
        xfs_repair处理XFS文件系统
            当有xfs文件系统错乱使用该指令
                xfs_repair [-fnd] 设备名称
                    -f 设备为文件而非实体装置
                    -n 只检查不修改文件系统的任何数据
                    -d 通常用于单人维护模式下，针对根目录进行检查和修复
            检查流程：
                Inode  and  inode  blockmap  (addressing) checks
                Inode allocation map checks
                Size  checks
                Directory checks
                Pathname checks
                Link count checks
                Freemap  checks
                Super Block checks
            修复时文件系统不能被挂载
            Linux的根目录无法被卸载，需要进入单人维护或修复模式，通过-d选项哎处理。
        fsck.ext4处理EXT4文件系统
            fsck为综合指令，针对ext4使用fsck.ext4即可
                fsck.ext4 [-pf] [-b superblock] devicename
                    -p 当文件系统在修复时，如果有需要输入y的自动确认
                    -f 强制检查，如果没有发现任何unclean，不会主动进入细节检查，-f则会
                    -D 针对文件系统下的目录进行优化配置
                    -b 接superblock的位置。如果superblock损毁，可利用文件系统内备份的superblock尝试修复，1K block在8193，2K block在16384，4K block在32768
            通常只有身份为root且文件系统有问题时才会使用这两个指令，否则正常情况下使用，可以会对系统造成危害
    文件系统挂载与卸载
        单一文件系统不应该被重复挂载在不同的挂载点(目录)中
        单一目录不应该重复挂载多个文件系统
        要作为挂载点的目录，应该都是空目录
        如果挂载了文件系统，原目录下的内容会暂时消失
            mount a
            mount [-l]
            mount [-t filesystem] LABEL='' 挂载点
            mount [-t filesystem] UUID='' 挂载点
            mount [-t filesystem] DEVICE='' 挂载点
                -a 按照配置文件/etc/fstab的数据将所有未挂载的磁盘都挂载上‘
                -l 只输入mount会显示目前挂载的信息，-l增加Label名称
                -t 加上文件系统种类来指定要挂载的类型，Linux常见的支持类型：xfs,ext3,ext4,reiserfs,vfat,iso9660(光盘格式),nfs,cifs,smbfs(后三种为网络文件系统类型)
                -n 在默认情况下，系统会将实际挂载的情况实时写入/etc/mtab中，以利用其他程序的运行。在某些情况下(如单人维护模式)为了避免问题会不写入，可以使用-n
                -o 接一些挂载时额外加上的参数，例如账号、密码、读写权限等
                    async,sync  此文件系统是否使用同步写入(sync)或异步写入的内存机制，预设为async
                    atime,noatime   是否修改文件的读取时间。为了效率有些时候可以使用noatime
                    ro,rw       挂在文件系统成为只读(ro)或可擦写
                    auto,noauto 允许此filesystem被以mount -a自动挂载(auto)
                    dev,nodev   是否允许此filesystem可建立设备文件，dev为可允许
                    sudi,nosuid 是否允许此filesystem含有suid/sgid的文件格式
                    exec,noexec 是否允许此filesystem上拥有可执行二进制文件
                    user,nouser 是否允许此filesystem让任何使用者执行mount?一般来说，mount只有root可以进行，user参数让一般user也能对此partition进行mount
                    defaults    默认值为，rw,suid,dev,exec,auto,nouser,async
                    remount     重新挂载，在系统出错或者重新更新参数时可用
        目前的一些系统不需要加上-t，系统会自动分析最合适的文件系统来尝试挂载设备。Linux通过分析superblock搭配Linux自己的驱动程序去测试挂载。系统会指定类型的filesystem需要进行挂载测试，主要参考：
            /etc/filesystems    系统指定的测试挂载文件系统类型的优先级
            /proc/filesystems   Linux系统已经加载的文件系统类型
        Linux支持的文件系统的驱动程序在
            /lib/modules/$(uname -r)/kernel/fs/
        使用UUID来挂载更为可靠，因为其唯一性
        挂载xfs/ext4/vfat等文件系统
        挂载CD或DVD光盘
            光驱一旦挂载后无法退出光盘片，除非将其卸载。无法读写，所以磁盘使用率为100%。图形界面系统会自动挂载到/media，可以不卸载就直接退出
        挂载vfat USB磁盘
            如果带有中文文件名的数据，可以在挂载时指定挂在文件系统所使用的语系数据。在man mount找到vfat文件格式中可用使用的codepage来处理。中文语系代码为950，编码使用iochcarset设定
        重新挂载根目录与不挂载特定目录
            如果需要改变挂载参数或者根目录出现只读状态时，可以重新启动，也可以重新挂载
                mount -o remount,rw,auto /
            进入单人维护模式时，根目录常会被系统挂载为只读
            可以利用mount来讲某个目录挂载到另一个目录，属于额外挂载某个目录。虽然可以使用符号链接，但在某些程序中不支持符号链接
                mount --bind old new
            也能实现链接到同一个inode
        umount(将设备文件卸载)
            umount [-fn] 设备文件名或挂载点
                -f 强制卸载，可用在类似网络文件系统NFS无法读取到的情况下
                -l 立即卸载文件系统
                -n 不更新/etc/mtab情况下卸载
    磁盘文件系统参数修改
        mknod
            Linux通过文件的major与minor数值来表示类型
                磁盘文件名  Major   Minor
                /dev/sda    8       0-15
                /dev/sdb    8       16-31
                /dev/loop0  7       0
                /dev/loop1  7       1
            Linux内核2.6版本后，硬件文件名可以被系统自动实时产生，不需要手动建立设备文件。某些情况下需要手动处理，如某些服务被关到特定目录下时(chroot)
                mknod   device  [bcp] [Major] [Minor]
                    b 设定设备名称为一个周围存储设备文件，例如磁盘
                    c 设定设备名称为一个周围输入设备文件，例如鼠标、键盘
                    p 设备设备名称为一个FIFO文件
                    Major 主要设备代码
                    Minor 次要设备代码
        xfs_admin修改XFS文件系统的UUID与Label name
            可以用来处理Label name与UUID，不需要重复格式化
                xfs_admin [-lu] [-L label] [-U uuid] 设备文件名
                    -l 列出设备的label name
                    -u 列出设备的UUID
                    -L 设定设备的label name
                    -U 设定设备的UUID
        tune2fs修改ext4的label name与UUID
            tune2fs [-l] [-L Label] [-U uuid] device
                -l 类似dumpe2fs -h，列出superblock数据
                -L 修改Label name
                -U 修改UUID

### 7.4 设定开机挂载

    开机挂载/etc/fstab和/etc/mtab
        系统挂载限制
            根目录/必须挂载，并且需要先于其他mount point被挂载进来
            其他挂载点必须为已建立的目录，可任意指定，但要遵守系统目录架构原则(FHS)
            所有挂载点在同一时间内，只能挂载一次
            所有分区在同一时间内，只能挂载一次
            如果进行卸载，需要先将工作目录转移到挂载点(及其子目录)之外
        cat /etc/fstab，在mount进行挂载时，所有的选项和参数都会写入这个文件。/etc/fstab还加入了dump备份用指令的支持。与开机时是否进行文件系统检验fsck等指令有关，数据
            Device/UUID等   挂载点  文件系统    文件系统参数    dump    fsck
        /etc/fstab是开机时的配置文件，实际filesystem的挂载点是记录到/etc/mtab和/proc/mounts这两个文件当中的。每次修改filesystem的挂载时，也会同时修改这两个文件。如果/etc/fstab错误，从而无法开机，在单人维护模式中，/为只读，/etc/fstab无法修改
            mount -n -o remount,rw /
    特殊设备loop挂载(映像文件不刻录就挂载使用)
        挂载光盘/DVD映像文件
            mount -o loop .iso dirname
            从而不需要将文件刻录成光盘或是DVD
        建立大文件以制作loop设备文件
            dd if=/dev/zero of=loopdev bs=1M count=512，压缩指令
            mkfs.xfs -f loop
            mount -o loop device/uuid dirname
            能够在原本的分区槽中，在不变更原有的环境下制作出想要的分区槽
            新系统不需要-o loop选项参数，也能够进行挂载

### 7.5 内存置换空间(swap)的新建

    早期因为内存不足，需要内存置换空间，暂时将内存的程序拿到硬盘中暂存。早期安装Linux时，需要两个分区，一个是根目录，另一个是swap
    一般来说，如果硬件的配置资源足够，swap应该不会被系统使用到，swap会被利用到的情况即为物理内存不足。
    对于服务器最好需要预留swap来缓冲系统内存用量
        设定一个swap partition
        建立一个虚拟内存的文件
    使用实体分区槽新建swap
        分区：先使用gdisk在磁盘中分区出一个分区槽给系统作为swap。由于Linux的gdisk预设会将分区槽的ID设定为Linux的文件系统，所欲需要设定system ID
        格式化：利用建立swap格式的mkswap device就能格式化该分区槽成为swap格式
        使用：最后将该swap设备启动，swapon device
        观察：通过free和swapon -s查看内存用量
    使用文件新建swap
        利用dd来新建一个大文件
        swapoff关闭swap file
        同样可以通过nano /etc/fstab来自动启用swap
    如果主机支持电源管理模式，当Linux主机系统进入休眠模式时，运行当中的程序也会被记录到swap，以作为唤醒主机的状态依据。有些程序在运行时，也会利用swap的特性去存放一些数据段。

### 7.6 文件系统的特殊观察与操作

    磁盘空间的浪费问题
        ll -sh可以查看实际占用的容量:block数量*block大小
    利用GNU的parted进行分区行为(Optional)
        parted [device] [command [参数]]
            指令功能
                新增分区 mkpart [primary|logical|extended] [ext4|vfat|xfs] start end
                显示分区 print
                删除分区 rm [partition]
                修改格式 mklabel format
        输出信息：磁盘接口与型号、磁盘文件名与容量、每个扇区的大小、分区类型
            Number  分区槽号码
            Start   分区的起始位置
            End     分区的结束位置
            Size    二者相减，分区槽的大小
            File system 可能的文件系统类型
            Name    同gdisk的System ID
            固定输出单位
                unit [如mb]

## 八、文件与文件系统的压缩、打包与备份

### 8.1 压缩文件的用途与技术

    压缩后与压缩的文件所占用的磁盘空间大小，成为压缩比

### 8.2 Linux系统常见的压缩指令

    常见的压缩文件扩展名
        *.Z     compress程序压缩的文件
        *.zip   zip程序压缩的文件
        *.gz    gzip程序压缩的文件
        *.bz2   bzip程序压缩的文件
        *.xz    xz程序压缩的文件
        *.tar   tar程序打包的文件，并没有压缩过
        *.tar.gz tar程序打包的文件，并且经过gzip的压缩
        *.tar.bz2 tar程序打包的文件，并且经过bzip2的压缩
        *.tar.xz tar程序打包的文件，并且经过xz的压缩
    Linux上常见的压缩指令为gzip、bzip2以及最新的xz，而compress显得不那么流行。为了支持windows常见的zip，Linux也有zip指令。gzip是由GNU计划所开发出来的压缩指令，已经取代了compress。后来GNU又开发出了bzip2、xz，压缩比更好。但是这些指令都只能针对一个文件来压缩与解压缩。
    打包软件tar可以将很多文件打包成为一个文件。甚至是目录，但是不提供压缩功能。GNU又将整个tar与压缩的功能结合在一起
    gzip,zcat/zmore/zless/zgrep
        gzip是应用度最广的压缩指令，可以解压compress,zip与gzip等软件所压缩的文件，而gzip所建立的压缩文件为*.gz。
            gzip [-cdtv#] filename
            zcat filename.gz
                -c 将压缩的数据输出到屏幕上，可以通过数据流重定向来处理
                -d 解压缩的参数
                -t 可以用来检验一个压缩文件的一致性，检查文件是否有错误
                -v 显示出原文件/压缩文件的压缩比等信息
                -# #为数字，代表压缩等级，-1最快压缩比最差，-9最慢压缩比最好，-6为预设
            在使用gzip进行压缩时，在预设的状态下原本的文件会被压缩成为.gz的文件名，源文件就不再存在了，与windows不同。使用gzip压缩的文件在Windows系统中，可以被WinRAR/7zip软件解压。
            可以用zcat/zmore/zless读取压缩包的内容，zgrep可以搜索
            同样，gzip -d解压后源文件也不存在
            使用数据流重定向
                gzip -c oldname > newname.gz
            znew苦于将compress压缩成的.Z文件转化为gzip的格式
    bzip2,bzcat/bzmore/bzless/bzgrep
        用法基本与gzip相同
            bzip2 [-cdkzv#] filename
            bzcat filename.bz2
                -c 将压缩的过程产生的数据输出到屏幕上
                -d 解压缩的参数
                -k 保留源文件，而不删除原始的文件
                -z 压缩的参数(默认值，可以不加)
                -v 显示出原文件/压缩文件的压缩比等信息
                -# 与gzip相同，-9最佳，-1最快
    xz,xzcat/xzmore/xzless/xzgrep
        用法与前两个基本相同
            xz [-dtlkc#] filename
            xcat filename.xz
                -d 解压缩
                -t 测试压缩文件的完整性
                -l 列出压缩文件的相关信息
                -k 保留原本的文件不删除
                -c 将压缩的数据输出到屏幕上
                -v 显示出原文件/压缩文件的压缩比等信息
                -# -9最佳，-1最快
    通过time + [command]可以查看时间

### 8.3 打包指令：tar

    tar
        tar [-z|-j|-J] [cv] [-f 待新建的新文件名] filename ...  打包与压缩
        tar [-z|-j|-J] [tv] [-f 已有的tar文件名]    查看打包文件内的文件名
        tar [-z|-j|-J] [xv] [-f 已有的tar文件名] [-C 目录]      解压缩
            -c 建立打包文件，可以搭配-v来查看过程中被打包的文件名(filename)
            -t 查看打包文件的内容含有的文件名
            -x 解打包或解压缩的功能，搭配-C在特定目录解开
                -c,-t,-x不可以同时出现
            -z 通过gzip的支持进行压缩/解压缩，文件名最好为*.tar.gz
            -j 通过bzip2的支持进行压缩/解压缩，文件名最好为*.tar.bz2
            -J 通过xz的支持进行压缩/解压缩，文件名最好为*.tar.xz
                -z,-j,-J不能同时出现
            -v 在压缩/解压缩的过程中，将正在处理的文件名显示出来
            -f fimename 接要被处理的文件名
            -C dirname 解压缩时指定解压缩到特定目录
            -p 保留备份数据的原本权限与属性，常用于备份(-c)重要的配置文件
            -P 保留绝对路径，即允许备份数据中含有根目录存在
            --exclude=FILE 在压缩过程中，不要将FILE打包
        使用tar加入-z,-j,-J的参数备份/etc目录
        查阅tar文件的数据内容(可查看文件名)，以及备份文件名是否有根目录的意义
            去掉根目录，否则解压时产生为绝对路径，就会将原数据覆盖
        将备份的数据解压缩，并考虑特定目录的解压缩操作(-C)
        只解压单一文件
            tar -jxv -f 打包文件.* 需要解压的文件
            路径写的是打包文件内的路径
        打包某目录，但不含该目录下某些文件
        仅备份比某个时刻还要新的文件
            --newer-mtime="YYYY/MM/DD" file
        基本名称，tarfile、tarball
            tar打包出来的文件是否进行压缩得到的文件称呼不同，仅打包成为tarfile，打包并压缩称为tarball
            tar还可以将文件打包到某些特别装置，例如磁带机
        特殊应用：利用pipe指令与数据流
            tar可以通过标准输入输出的数据流重定向，以及pipe的方式，将待处理的文件一边打包一边解压缩到目标目录去
                tar -cvf - file | tar -xvf -
            从而避免使用cp -r产生中间文件
        系统备份
            重要的目录
                /etc 配置文件   /home 用户主目录
                /var/spool/mail 系统中，所有账号的邮件信箱
                /var/spool/cron 所有账号的工作配置文件
                /root 系统管理员的主目录
            并且，/root下的压缩文件、/home/loop*不需要备份
                mkdir /backups
                chmod 700 /backups 
                tar -jcv -f /backups/backup-system-(time).tar.bz2 \ 
                --exclude=/root/*.bz2 --exclude=/root/*.gz --exclude=/home/loop* \ 
                /etc /home /var/spool/mail /var/spool/cron /root
        解压缩后的SELinux问题
            如果因为某些原因，系统必须要以备份的数据来回填到原本的系统中，需要注意复原后的系统的SELinux问题，特别是在系统文件上。SELinux是比较特比的细节权限设定。SELinux的权限问题可能会让系统无法存取某些配置文件内容，导致影响到系统的正常使用权
            很可能的原因和现象是，/etc/shadow密码文件的SELinux类型在还原时被更改了，导致系统的登录程序无法顺利的存取
            处理方式
                通过各种可行的修复方式登录系统，然后修改/etc/selinux/config文件，将SELinux改成permissive模式，重新启动
                在第一次复原系统后，不要立即重新启动。先使用restorecon-Rv/etc自动修复一下SELinux的类型
                通过各种可行的方式登录系统，建立/.autorelabel文件，重新启动后系统会自动修复SELinux的类型，然后再次重新启动

### 8.4 XFS文件系统的备份与还原

    tar是针对目录树系统进行备份，对于整个文件系统，应该使用xfsdump与xfsrestore
    XFS文件系统备份xfsdump
        除了可以进行文件系统的完整备份意外，还可以进行累计备份。假设/home为独立的一个文件系统，在第一次使用xfsdump进行完整备份后，经过一段时间文件系统运行后，在进行第二次xfsdump时，就可以选择累计备份。此时新备份的数据只会记录与第一次有差异的文件
        第一次备份一定为完整备份，定义为level0。各个level的记录文件放置于/var/lib/xfsdump/inventory
        使用xfsdump时的限制
            xfsdump不支持没有挂载的文件系统备份
            xfsdump必须使用root权限才能操作
            xfsdump只能备份XFS文件系统
            xfsdump备份的数据(文件或存储媒体)只能由xfsrestore解析
            xfsdump是通过文件系统的UUID来分别各个备份的，因此不能备份两个具有相同UUID的文件系统
            xfsdump [-L S_label] [-M M_label] [-l #] [-f 备份文件] 待备份文件
                -L xfsdump会记录每次备份的session标头，可以填写针对此文件系统的简要说明
                -M xfsdump可以记录存储媒体的标头，可以填写此媒体的简要说明
                -l 指定等级，预设为0完整备份
                -f 类似于tar，接产生的文件，也可接设备文件名
                -I 从/var/lib/xfsdump/inventory列出目前备份的信息状态
        xfsdump预设仅支持文件系统的备份，不支持特定目录的备份
        用xfsdump备份完整的文件系统，例如
            xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot
        用xfsdump进行累计备份
        xfsdump -I查看
    XFS文件系统还原xfsrestore
        xfsrestore -I   查看备份文件系统
        xfsrestore [-f 备份文件] [-L S_label] [-s] 待复原目录   单一文件全系统复原
        xfsrestore [-f 备份文件] -r 待复原目录  通过累计备份文件来复原
        xfsrestore [-f 备份文件] -i 待复原目录  进入互动模式
            -I 与xfsdump -I相同的输出，可查询备份数据，包括Label名称与备份时间等
            -f 接备份文件
            -L Session的Label name
            -s 需要接特定目录，即仅复原某一个文件或目录
            -r 如果是用文件来存储备份数据，则不需要使用；如果一个磁带内有多个文件，需要-r来完成累计复原
            -i 进入互动模式，专家使用
        用xfsrestore观察xfsdump后的备份数据内容
        复原level 0的文件系统，例如
            xfsrestore -f /srv/boot.dump -L boot_all /boot
            也可以在特定目录解开备份资料，直接复原：同名的文件会被覆盖，系统内的新文件会被保留
            -s能够只复原特定目录或文件
        复原累计备份资料，例如
            xfsrestore -f /srv/boot.dump1 /tmp/boot
            流程基本一致
        仅还原部分文件的xfsrestore互动模式
            -i互动模式，有更多指令

### 8.5 光盘写入工具

    文本模式的刻录操作通常做法
        先将所需要备份的数据新建为一个映像文件(iso)，利用mkisofs来处理
        将该映像文件刻录至光盘或DVD中，利用cdrecord指令来处理
    mkisofs：新建映像文件
        刻录可开机和不可开机的光盘，方法不一样
        制作一般数据光盘映像文件
            要利用刻录机将数据刻录到DVD，需要先将数据制作成映像文件。
                mkisofs [-o 映像文件] [-Jrv] [-V vol] [-m file] 需要备份的文件 ... -graft-point isodir=systemdir ...
                    -o 接要制作的映像文件文件名
                    -J 产生比较兼容于windows系统的文件名结构，可增加文件名长度到64个unicode字符
                    -r 通过Rock Ridge产生支持Unix/Linux的文件数据，可记录较多的信息(如UID/GID等)
                    -v 显示新建ISO文件的过程
                    -V vol 新建Volume，类似于Windows在文件资源管理器中的CD title
                    -m file 排除文件，接的文件不备份到映像文件中，可以使用通配符
                    -graft-point 有转嫁或移植的意思
            光盘的格式一般称为iso9600，这种格式一般仅支持旧版的DOS文件名，即文件名只能以8.3(文件名8个字符，扩展名3个字符的方式存在)。加上-r后，文件信息能够被记录得比较完整
            一般预设的情况下，所有要被加到映像文件中的文件都会被放置到映像文件中的根目录，使用-graft-point，可以定义位于映像文件中的目录
                映像文件中的目录所在=实际Linux系统的目录所在
            可以先将所有的数据预先处理到某一个目标中，再进行刻录
        制作/修改可开机光盘映像文件
            isoinfo -d -i *.iso 查看光盘内容
            rsync -a src des    完整复制所有的权限属性等数据，也能够进行镜像处理
            例如 mkisofs -o /custom.iso -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -V 'CentOS 7 x86_64' -boot-load-size 4 -boot-info-table -R -J -v -T . 
    cdrecord，光盘刻录工具
        新版系统有使用具有文字界面的wodim来进行刻录。为了兼容于旧版的cdrecord，wodim也有链接到cdrecord。
            wodim --devices dev=/dev/sr0 ...    查询刻录机的BUS位置
            wodim -v dev=/dev/sr0 blank=[fast|all]  抹除重复读写片
            wodim -v dev=/dev/sr0 -format       格式化DVD+RW
            wodim -v dev=/dev/sr0 [可用选项功能] file.iso
                --devices   用在扫描磁盘总线并找出可用的刻录机，后续的设备为ATA接口
                -v          在cdrecord运行的过程中，显示过程
                dev=/dev/sr0 可用找出此光驱的bus地址
                blank=[fast|all] blank为抹除可重读写入的CD/DVD-RW，使用fast较快，all较完整
                -format     对光盘进行格式化，仅针对DVD+RW这种格式
                [可用选项功能] 主要为写入CD/DVD时可使用的选项
                    -data   指定后面的文件以数据格式写入，不是以CD音轨(-audio)方式写入
                    speed=X 指定刻录速度，例如CD可用speed=40，DVD可用speed=4
                    -eject  指定刻录完毕后自动退出光盘
                    fs=Ym   指定多少缓冲存储器，可用在将映像文件先暂存到缓冲存储器，预设为4M，一般建议增加到8M，取决于刻录机
                针对DVD的选项功能
                    driveropts=burnfree 打开Buffer Underrun Free
                    模式的写入功能
                    -sao    支持DVD-RW的格式
        检测刻录机所在位置
            早期的刻录机使用SCSI接口，查询
                wodim --devices dev=/dev/sr0
        进行CD/DVD刻录
            若为可重复读写，先抹除光盘的原始内容
                wodim -v dev=/dev/sr0 blank=fast
                会提示抹除进度，并且有10s时间等待取消
            开始刻录
                wodim -v dev=/dev/sr0 speed=4 -dummy -eject /tmp/system.img

### 8.6 其他常见的压缩与备份工具

    dd
        dd可用读取磁盘设备的内容(几乎是直接读取扇区)，然后将整个设备备份成一个文件
            dd if="input_file" of="output_file" bs="block_size" count="number"
                if input file，也可以是设备
                of output file，也可以是设备
                bs block size，预设512bytes(一个扇区大小)
                count block数量
        输出结果中的，m+n，表示有m个完整的，n个不完整的(n大多数为1)
        dd会将没有使用到的扇区也倍写备份文件中，所以文件会和原本磁盘一样大。而且与文件系统无关
        如果需要进行挂载，需要考虑每个文件系统的挂载要求，例如xfs文件系统内的log需要被清除，然后赋予新的uuid
        uuidgen生成UUID，xfs_growfs文件系统放大
    cpio
        cpio可用备份任何东西，包括装置设备文件。但是不会主动寻找文件来备份，需要配个类似find的工具。
            cdip -ovcB > [file|device]  备份
            cpio -ivcdu < [file|device] 还原
            cpio -ivct < [file|device]  查看
            备份使用的选项和参数
                -o 将数据copy输出到文件或设备上
                -B 让预设的blocks可以增加到5120bytes，预设为512bytes。可以让大文件的存储速度加快
            还原使用到的选项和参数
                -i 将数据从文件或设备copy出来到系统中
                -d 自动建立目录
                -u 自动的将较新的文件覆盖较旧的文件
                -f 需要配合-i，可用在查看来cpio建立的文件或设备的内容
            共享的选项和参数
                -v 显示存储过程中的文件名
                -c 以较新的portable format方式存储
        例如find boot | cpio -ocvB > /tmp/boot.cpio
        通过pile进行数据流重定向。注意不要加上绝对路径的/开头，否则解开的时候，一定会覆盖掉原来的内容
        cpio还可以将系统的数据完整地备份到磁带机上

## 九、vim程序编辑器

    在所有的Linux版本上都会有一套文本编辑器vi，很多软件默认使用vi作为编辑接口。vim是进阶版的vi，可以用不同颜色显示文字内容，还能进行shell script、C语言等程序编辑功能

### 9.1 vi与vim

    Linux中，绝大部分的配置文件以ASCII的纯文本形式存在。Linux在文本接口下的文本编辑器：emacs、pico、nano、jor和vim
    使用vi的原因
        主要原因
            所有的Unix Like系统都会内建vi文本编辑器，其他的不一定存在
            很多个别软件的编辑接口都会主动呼叫vi(例如crontab、visudo、edquota)
            vim具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计
            程序简单，编辑速度相当快速
        vim还支持正规表示法的搜寻架构、多文件编辑、区块复制等

### 9.2 vi的使用

    vi共分为三种模式
        一般指令模式(command mode)
            以vi打开一个文件就直接进入一般指令模式(默认模式，也称为一般模式)。可以上下左右来移动光标，可以使用删除字符或删除整列来处理文件内容，也可以使用复制粘贴来处理文件数据
        编辑模式(insert mode)
            在一般指令模式中可以进行删除、复制、粘贴等操作，但是无法编辑文件内容。需要按下[i,I,o,O,a,A,r,R]等任何一个字母之后才会进入编辑模式。按下这些按键后，画面的左下方会出现INSERT或REPLACE字样，回到一般指令模式，按下Esc即可
        指令行指令模式(command-line mode)
            在一般模式当中，输入[:,/,?]中任何一个，就可以将光标移动到最底下，可以提供查找数据的操作，而读取、存盘、大量替换字母、离开vi、显示行号等操作都是在此模式下实现的。
    简单执行
        使用vi filename进入一般指令模式
            /bin/vi filename，一般帐号预设使用vim来替代。所以需要使用绝对路径的方式来执行/bin/vi(实际测试时都只会打开vim)。vi后面必须接文件名
            上半部分显示文件实际内容，最底下一列为状态显示/指令下达列
        按下i进入编辑模式，开始编辑文字
            在该模式下，除了Esc之外，其他的按键都视为一般输入按钮
        按下Esc按钮回到一般指令模式
        进入指令行模式，文件存储并离开vi环境
            输入:wq存档离开。如果文件权限不符合，可能会无法写入，在权限可以改变的情况下，:wq!可以强制写入
    按键说明
        一般指令模式可用的按钮说明，光标移动、复制粘贴、查找替换等
        注意，非组合键需要注意大小写
          光标移动
            h,← 左移    j,↓ 下移    k,↑ 上移    l,→ 右移
            如果要进行多次移动，可用30j或30↓的组合输入
            Ctrl+f 向下移动一页，PageDown
            Ctrl+b 向上移动一页，PageUp
            Ctrl+d 向下移动半页，Ctrl+u 向上移动半页
            Ctrl+- 光标移动到非空格符的下一列 - 光标移动到非空格符的上一列
            n<space>光标向右移动n个字符，能够跨行
            0,Home  移动到该行的第一列(第一个字符)
            $,End   移动到该行的最后一列(最后一个字符)
            H       移动到屏幕最上方那一行的第一个字符
            M       移动到屏幕中间那一行的第一个字符
            L       移动到屏幕最下方那一行的第一个字符
            G       移动到这个文件的最后一行的第一个字符
            nG      移动到这个文件的第n行
            gg      移动到这个文件第1行，1G
            n<Enter>向下移动n列
          查找替换
            /word   从光标位置开始向后查找字符串word
            ?word   向前查找字符串word
            n       重复前一个查找动作
            N       反向进行前一个查找动作
            :n1,n2s/word1/word2/g   在第n1到n2行直接寻找word1，并将其替换为word2
            :1,$s/word1/word2/g     在所有文本范围内寻找word1并替换为word2
            :1,$s/word1/word2/gc     在所有文本范围内寻找word1并替换为word2，需要进行确认
          删除、复制与粘贴
            x,X x向后删除Del，X向前删除backspace
            nx  连续向后删除n个字符
            dd  删除光标所在整行(剪切)
            ndd 删除光标所在的向下n行
            d1G 删除光标所在到第一行的所有内容
            dG  删除光标所在到最后一列的所有内容
            d$  删除光标所在到该行的最后一个字符
            d#/d0 删除光标所在到该行的第一个字符
            yy  复制光标所在的那一行
            nyy 复制光标所在的向下n列
            y1G 复制光标所在行到第一行的所有内容
            yG  复制光标所在行到最后一行的所有内容
            y#/y0 复制光标所在的字符到该行列首的所有内容
            y$  复制光标所在的字符到该行列尾的所有内容
            p,P p将已经复制的数据在光标下一行粘贴上(如果不是行操作，则是在光标后粘贴，P同理)，P粘贴在光标上一行
            J   将光标所在行与下一行的内容合并，空格间隔
            c   重复删除多个内容，例如10cj，向下剪切11行，并进入编辑模式
            u   撤回前一个动作
            Ctrl+r 恢复上一个动作
            .   重复上一个动作
          一般指令模式切换到编辑模式
            i,I 进入插入模式(Insert mode)。i为从目前光标所在处插入，I为在目前所在行的第一个非空格符处开始插入
            a,A 进入插入模式。a为从目前光标所在的下一个字符处开始插入，A为从光标所在行的最后一个字符处开始插入
            o,O 进入插入模式，o为在目前光标所在的下一行处插入新的一行，O为在目前光标所在的上一行插入新的一行
            r,R 进入替换模式(Replace mode)。r只会替换光标所在的那一个字符一次，R会一直取代光标所在的字符，直到按下Esc
                实际测试中，r+字符，不会进入编辑模式，只会将光标所在的字符替换
            Esc 退出编辑模式，回到一般指令模式
          一般指令模式切换到指令行模式
            :w  将编辑的数据写入硬盘文件中
            :w! 若文件属性为只读时，强制写入该文件。最终能否写入，与对文件的权限有关
            :q  离开vi
            :w! 强制写入该文件
            :q  离开vi
            :q! 如果修改过文件而且不保存，强制离开
            :wq 保存后离开，:wq!为强制保存后离开
            ZZ  如果文件没有修改，则不保存离开，修改过，则保存后离开
            :w [filename] 将编辑的内容另存为
            :r [filename] 在编辑的内容中，读入另一个文件的数据，即将filename这个文件内容加到光标后
            :n1,n1 w [filename] 将n1到n2行的内容保存为filename
            :! command 暂时离开vi到指令行模式下执行command的显示结果
            :set nu 显示行号，在每一行的前缀显示
            :set nonu 取消行号
    vim的暂存文件、修复恢复和开启时的警告信息
        目前主要的文本编辑软件都有恢复的功能，通过某些特别的机制来将为存储的数据恢复。vim通过暂存文件来修复。
        在使用vim编辑时，vim会在被编辑的文件的目录下，再建立一个名为.filename.swp的文件。
        如果vim工作被不正常中断，导致暂存盘无法通过正常流程结束，暂存文件不会消失。
        警告信息可用
            [O]pen Read-Only：打开此文件成为只读文件，可以用在查阅该文件内容而不进行编辑的情况
            [E]dit anyway：使用正常的方式打开文件，不会载入暂存盘的内容
            [R]ecover：加载暂存盘的内容，用来恢复之前未存储的工作
            [D]elete if：在开启文件前会将暂存盘删除
            [Q]uit：离开vim
            [A]bort：忽略编辑行为，与quit类似

### 9.3 vim的额外功能

    目前大部分的版本都用vim替代vi的功能了。vim支持颜色显示，程序语法，所以能够进行debug
    如果输入vim /etc/services，/etc/services是系统规划的配置文件，会有语法高亮和检验；底下一行，都能显示文件属性、字符数、光标位置
    区块选择(Visual Block)
        区块选择能够对光标起始之间的内容、整行内容、矩形区域内容进行选择
            v   字符选择，会将光标经过的地方反白选择
            V   行选择，会将光标经过的行反白选择
            Ctrl+V  区块选择，用长方形的方式选择内容
            y   将反白的区域复制起来
            d   将反白的区域删除
            p   将复制的区块，粘贴到光标的位置
    多文件编辑
        :r filename能够读入文件内容，多文件同时编辑能够实现部分读入
            :n  编辑下一个文件
            :N  编辑上一个文件
            :files 列出目前这个vim开启的所有文件
        多窗口使用鼠标复制，会将格式破坏，例如制表符变为空格
        vim指令打开多个文件
    多窗口功能
        在一般窗口接口下的编辑软件大多有分区窗口或者冻结窗口的功能来将文件分区成多个窗口，vim在指令行模式输入
            :sp [filename]，有filename时在新窗口启动另一个文件，没有则将同一个文件在两个窗口显示
            Ctrl+w+j/↓  切换到下面的窗口，先按下Ctrl+w，然后再按第三个键
            Ctrl+w+k/↑  切换到上面的窗口
            Ctrl+w两侧，循环切换窗口
            Ctrl+w+q    关闭当前窗口
    vim的挑字补全功能
        在编辑模式下
            Ctrl+x->Ctrl+n  通过目前正在编辑的这个文件的内容作为关键词，予以补齐
            Ctrl+x->Ctrl+f  以当前目录内的文件名作为关键词，予以补齐
            Ctrl+x->Ctrl+o  以扩展名作为语法补充，以vim内建的关键词，予以补充
        注意扩展名需要匹配
    vim环境设定与记录：~/.vimrc,~/.viminfo
        vim会主动将曾经的操作记录下来，并保存到~/.viminfo
            :set all    查看所有的环境参数设定值
            :set nu         显示行号    :set nonu       取消显示
            :set hlsearch   高亮查找    :set nohlsearch 取消高亮
            :set autoindent 自动缩排    :set noautoindent
            :set backup     自动储存备份文件，一般nobackup
            :set ruler      显示设定值
            :set showmode   显示操作(如--INSERT--)状态栏
            :set backspace=(012)    2可以删除任意字符，01仅能删除输入的字符
            :set 显示与系统默认值不同的设定参数
            :set syntax on  语法高亮，off关闭
            :set bg=dark    色调暗，light亮，默认亮
        vim设定值一般放置在/etc/vim/vimrc，但是不建议修改，可以修改~/.vimrc(预设不存在则手动建立)
            "双引号为批注
            set hlsearch    "高亮反白
            set backspace   "随时退格键删除
            set autoindent  "自动缩排
            set ruler       "显示最后一列状态
            set showmode    "左下角一行状态
            set nu          "显示行号
            set bg=dark     "显示底色色调
            syntax on       "语法高亮
    vim常用指令
        光标移动，hjkl，1G,$,G,^
        整行删除复制粘贴，dd yy Pp
        两行合并J，字符删除x、X、dw
        查找/,nN，保存离开ZZ
        撤销恢复，u,Ctrl+r
        区块选择复制粘贴，v,y,p,d
        窗口分割，:sp file,Ctrl+w+s,Ctrl+v
        查找替换，:n1,n2s/old/new/g[e]

### 9.4 其他vim使用注意事项

    中文编码问题
        中文编码有big5和utf8两种，需要考虑
            Linux系统默认支持的语系，与/etc/locale.conf
            终端界面的语系，与LANG,LC_ALL有关
            文件原本的编码
            开启终端机的软件
        LANG=format;export LC_ALL=format
    DOS与Linux的断行符
        DOS的断行字符为^M$，称为CR和LF，而Linux只有LF($)这个断行符
        字符转换指令
            dos2unix [-kn] file [newfile]
            unix2dox [-kn] file [newfile]
                -k 保留该文件原本的mtime时间
                -n 保留原本的文件，将转换后的内容保存到新文件
        相同的文件转换前后，dos会大一点
        file filename可以查看文件格式
    语系编码转换
        iconv --list
        iconv -f 原编码 -t 新编码 filename [-o newfile]
            --list  列出iconv支持的语系
            -f      接原编码
            -t      接新编码
            -o file 保留原本的文件，保存到新文件
        iconv支持的语系非常多，包括中文的big5,utf8,gb2312
        将繁体中文的uft8转化为简体中文的utf8
            iconv -f utf8 -t big5 vi.utf8 | iconv -f big5 -t gb2312 | iconv -f gb2312 -t utf8 -o vi.gb.utf8

## 十、认识与学习BASH

### 10.1 shell for bash

    管理整个计算机硬件的为操作系统内核，一般使用者只能通过shell来与内核通信。
    硬件、核心与Shell
        通过Shell将输入的指令与Kernel通信，来让Kernel可以控制硬件来正确工作
        操作系统其实为一组软件，这组软件控制整个硬件与管理系统的活动监测，如果这组软件能够被用户随意操作，可能会因为应用不当，使整个系统崩溃
        shell有外壳之意，表示应用程序在最外层
        只要能够操作应用程序的接口都可以被称为shell。狭义的shell指的是指令行方面的软件；广义则包括图形接口的软件
    文本接口的shell
        文本接口的shell，在各个版本的bash都相同，不会出现版本升级或管理模块套件不统一的问题。
        远程管理，文本接口传输更快，不易出现断线或信息泄露
        shell能够有效管理主机，shell可以所提供的数据流重定向和pipe指令，能够有效提升效率
    系统的合法shell与/etc/shells功能
        早期Unix的版本众多，shell依据发展者的不同就有许多版本，例如Bourne Shell、Sun预设的C Shell、商业常用的K Shell以及TCSH。Linux使用的版本称为Bourne Again Shell(简称bash)，为Bourne Shell的增强版，基于GNU的架构发展。
        Linux为C语言撰写的，所以C shell相对热门。
        在/etc/shells可以查看可用的shells
            /bin/sh(已经被/bin/bash取代)
            /bin/bash(Linux预设的shell)
            /bin/tcsh(整个C shell，提供更多功能)
            /bin/csh(被/bin/tcsh取代)
        各种shell的功能差不多，但是某些语法的下达不同。系统上合法的shell存储在/etc/shells，系统某些服务在运作过程中，会去检查使用者能够使用的shells。
        当登录的时候，系统会给一个shell来允许工作，记录在/etec/passwd内。每一行的最后一个数据，即为登陆后取得的预设shell
    Bash shell功能
        bash主要兼容于sh，并且根据使用者的需求而加强的shell版本。主要优点
        指令记忆功能(history)
            bash能够保存使用过的指令，在很多版本中，默认的指令记忆功能达到可以1000个。
            指令会被记录到主目录的.bash_history。而~/.bash_history记录的是前一次登录以前所执行过的指令，本次登录所执行的会被暂存在内存中，注销系统后才会被记录到.bash_history
            可能会存在一定隐患，如指令与系统有关(如直接输入MySQL的密码在指令行上)
        指令与文件补全功能(tab实现)
            tab的功能由bash提供
        指令别名设定功能
            alias 别名="原内容"
        工作控制、前景背景控制(job control,foreground,background)
            使用前、背景的控制可以让工作进行更为顺利，工作控制能够随时将工作放到后台执行。
        程序化脚本(shell scripts)
            可以将平时管理系统长需要下达的指令写成文件，通过交互式来进行主机检查工作，也可以通过shell提供的环境变量和相关指令来进行设计
        通配符(wildcard)
            bash还支持许多的通配符来帮助用户查询与下达指令。
    查询指令是否为bash shell的内建指令：type
        bash的说明文件也能够通过man bash查看
        许多指令例如cd、umash都内建在bash中，在bash的man page中也能查看它们的说明
            type [-tpa] name
                不加任何选项与参数时，type会显示出name为外部指令还是bash内建指令
                -t 只显示以下字眼
                    file    外部指令
                    alias   别名设定的指令
                    builtin bash内建的指令
                -p 若name为外部指令，显示出完整文件名
                -a 将PATH变量定义的路径中，所有含name的指令列出来
        type也可以实现类似which的功能，主要找出执行文件。
    指令的下达与快速编辑
        Enter下达指令，\Enter只换行不下达
            [ctrl]+u/k  分别从光标处向前/后删除指令
            [ctrl]+a/e  分别将光标一定到指令最前/后面

### 10.2 Shell的变量功能

    变量的定义
        用一个字符串取代另一个比较复杂或者容易变动的数据
        变量的可变性与方便性
            每个账号的邮件信箱预设是以MAIL这个变量来进行存取的，当用户登入时，便会取得MAIL这个变量，内容为/var/spool/mail//username。
            mail为指令，MAIL为变量名称
        影响bash环境操作的变量
            某些特定变量会影响到bash的环境。
            在Linux系统下，所有的线程需要一个PID，真正以shell与Linux通信，是在正确的登录Linux之后。在进入shell前，系统需要一些变量来提供数据的存取(或者是一些环境的设定参数值)，就需要一些环境变量来读入系统中，例如PATH、HOME、MAIL、SHELL，为了与自定义变量区别，环境变量通常以大写字母表示
        脚本程序设计(shell script)
            在不同主机上，script中的路径内容可以利用变量直接替换
        变量就是以一组文字或符号，来取代一些设定或者一串保留的数据
    变量的查看与设定：echo，变量设定规则，unset
        取用变量需要在变量前加上$
        变量的查看：echo
            echo $variable/${variable}
            variable=string，进行设定
        在bash中，一个变量名称未被设定时，预设的内容为空
        每种shell的语法都不相同，bash中echo空变量会显示空，有些shell会报错
        变量的设定规则
            变量与变量内容以等号=链接
            等号两边不能直接接空格
            变量名只能为英文字母与数字，开头字符不能为数字
            变量内容有空格可以用单/双引号'"将变量内容括住
                双引号内的特殊字符如$等，可以保有原有的特性
                单引号内的特殊字符仅为一般字符
            可用转义字符\来将特殊符号变成一般字符
            在一串指令的执行中，若需要其他额外的指令所提供的信息时，可用使用反单引号`command`或$(command)
            若变量需要扩增内容，可以用"$variable"或${variable}、$variable
            若变量需要在其他子程序执行，需要以export来使变量称为环境变量ls
            通常大写字符为系统默认变量，自行设定变量可以使用小写字符，方便判断
            取消变量的方法unset variable
        bash可以进入新的shell，也是一个子程序，在子程序内unset不会影响父程序的变量，并且也不会进入父程序的hitstory
    环境变量的功能
        环境变量能够实现较多功能，例如主目录的变换、提示字符的显示、执行文件搜索的路径等。
        用env查看环境变量与常见环境变量说明
            HOSTNAME    这部主机的主机名
            TERM        这个终端机使用的环境类型
            SHELL       当前环境使用的shell程序
            HISTSIZE    记录指令的数量
            OLDPWD      上一个工作目录
            LC_ALL
            USER        用户名称
            LS_COLORS   颜色显示
            MAIL        用户邮箱位置
            PATH
            PWD         目前用户所在工作目录(pwd查看)
            LANG        语系数据
            HOME        用户主目录
            LOGNAME     登录账号名
            _           上一次使用的指令最后一个参数(或指令本身)
            RANDOM      随机数，内容在0-32767之间
                declare -i number=$RANDOM*10/32768 ; echo $number，声明数据类型，给出0-9
        用set观察所有变量(含环境变量与自定义变量)
            bash的变量，有环境变量、bash操作接口有关的变量，以及用户自定义的变量
                BASH        bash主程序放置路径
                BASH_VERSINFO、BASH_VERSION bash版本
                COLUMNS     目前终端机环境下，使用的字段的字符长度
                HISTFILE    历史指令记录的文件
                HISTFILESIZE    与上一个文件有关，保存的历史指令数
                HISTSIZE
                IFS         预设分隔符
                MACHTYPE    安装的机器类型
                OSTYPE      操作系统类型
                PS1         指令提示字符
                PS2         使用\Enter后第二行的提示字符
                $           目前这个shell的PID
                ?           上一个指令的回传值
            不论是否为环境变量，只要与当前shell的操作接口有关，通常会被设定为大写字符。在Linux预设的情况中，使用大写字母来设定的变量一般为系统内定需要的变量。较为重要的变量
                PS1:提示字符的设定
                    指令提示字符
                    \d 可显示出[星期 月 日]的日期格式
                    \H 完整的主机名
                    \h 仅取主机名在第一个小数点之前的名字
                    \t 显示时间，24小时格式HH:MM:SS
                    \T 显示时间，12小时格式HH:MM:SS
                    \A 显示时间，24小时格式HH:MM
                    \@ 显示时间，12小时格式am/pm
                    \u 目前使用者的账号名称
                    \v BASH的版本信息
                    \w 完整的工作目录名称
                    \W 利用bashname函数取得工作目录名称
                    \# 下达的第几个指令
                    \$ 提示字符，如果是root提示为#，否则为$
                    如PS1='[\u@\h:\w \A #\#]\$ '
                $:当前shell的PID
                ?:上一个指令的回传值
                    当执行某些指令时，会回传一个执行后的代码。如果成功的执行该指令，会回传一个0
                OSTYPE,HOSTTYPE,MACHTYPE:主机硬件与内核的等级
                    不同等级的CPU指令集不同，软件可能会针对某些CPU进行优化。
                    较高阶的硬件通常会向下兼容旧有的软件。
        export:自定义变量变为环境变量
            环境变量与自定义变量的差异在于该变量是否会被子程序继续引用
            子程序仅会继承父程序的环境变量，子程序不会继承父程序的自定义变量
                export variable，将自定义变量变为环境变量
                export，不接变量能够显示目前的环境变量
                declare能够将环境变量变为
        影响显示结果的语系变量(locale)
            locale -a，显示Linux支持的语系
            locale显示变量使用的语系
            如果其他语系变量未被设定，在设定LANG或LC_ALL时，其他语系变量会被这两个变量所替换
            在Linux主机的终端机接口(tty1-tty6)的环境下，无法显示中文等复杂编码文字，需要在tty1-tty6加装一些中文化接口的软件。
            如果发生乱码问题，设定系统内保有的语系编码即可。使用locale时，系统会列出目前Linux主机内保有的语系文件，在/usr/lib/locale中
    变量的有效范围
        因为内存配置，环境变量的数据可以被子程序调用
            当启动一个shell时，操作系统会分配一个内存区块给shell，此内存的变量可以被子程序调用
            若在父程序利用export，可以让自定义变量的内容写到上述区块中
            当加载另一个shell时(启动子程序)，子程序可以将父shell的环境变量所在的内存区块导入自己的环境变量区块中
        环境变量与bash的操作环境不一样，PS1并非环境变量，但是会影响到bash
        的接口
    变量键盘读取、数组与声明:read,array,declare
        变量设定也可以由键盘输入。
        read
            要读取来自键盘输入的变量，可以用read指令。常被用在shell script中。
                read [-pt] variable
                    -p 接提示字符
                    -t 接等待的秒数
        declare/typeset
            二者是相同的功能，声明变量的类型。declare如果不接参数，会将所有的变量名称和内容列出来
                declare [-aixr] variable
                    -a 将变量定义为数组(array)
                    -i 将变量定义为整型(integer)
                    -x 将变量设置为环境变量
                    -r 将变量设定为只读，不能被更改和unset
            默认情况下，bash对变量的基本定义
                类型默认为字符串，数值运算预设为整型
            如果将变量设定为只读，需要注销再登陆才能恢复变量类型
        数组变量类型
            bash数组的设定方式
                var[index]=content
            不能一次性访问数组内所有内容
    与文件系统及程序的限制关系:ulimit
        bash可以限制用户的某些系统资源，包括可以开启的文件数量，可以使用的CPU时间，可以使用的内存总量等
            ulimit [-SHacdfltu] [配额]
                -H hard limit，严格设定，不能超过这个设定的数值
                -S soft limit，警告设定，可以超过，但是超过会有警告信息。在设定上，通常soft会比hard小。
                -a 不接任何选项和参数，列出所有的限制额度
                -c 当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件。这种文件就被称为内核文件。-c限制每个内核文件的最大容量
                -f 此shell可以建立的最大文件容量(一般可能设定为2GB)，单位Kbytes
                -d 程序可能使用的最大段内存(segment)容量
                -l 可用于锁定(lock)的内存量
                -t 可使用的最大CPU时间(单位为秒)
                -u 单一用户可以使用的最大程序(process)数量
        通过ulimit -a查看，0代表无限制
        一般用户如果设定了上限，只能继续减小上限，否则需要管理员设定
    变量内容的删除、取代与替换
        变量内容的删除与取代
            ${variable#format}，#表示从匹配format的内容最前面开始向右删除，并且删除最短(最先匹配到)的一个，##则是删除匹配的最长的一个
            %从最后面向左删除最先匹配到的最短的，%%则是删除匹配的最长的一个
            ${variable/old/new}，将第一个匹配的字符串替换为新的
            ${variable//old/new}，将所有匹配的字符串替换为新的
        变量的测试与内容替换
            变量设定方式        str未设定   str为空字符串   str不是空字符串
            var=${str-expr}    var=expr    var=           var=$str
            var=${str:-expr}   var=expr    var=expr       var=$str
            var=${str+expr}    var=        var=expr       var=expr
            var=${str:+expr}   var=        var=           var=expr
            var=${str=expr}    str=expr,var=expr str不变,var= str不变,var=$str
            var=${str:=expr}   str=expr,var=expr str=expr,var= str不变,var=$str
            var=${str?expr}    expr输出值stderr    var=    var=$str
            var=${str:?expr}   expr输出值stderr    expr输出值stderr var=$str

### 10.3 指令别名与历史指令

    指令别名设定:alias,unalias
        增设默认选项在惯用的指令上，能够预防误杀文件的情况。
        alias的定义规则与变量定义规则几乎相同，命令别名的设定也能取代既有的指令
            alias 别名='command 选项...'
            alias 查看所有指令别名
            unalias 别名，取消指令别名
    历史指令:history
        history [n]
        history [-c]
        history [-raw] histfiles
            n 列出最近的n笔指令列表
            -c 将目前的shell中所有的history全部清除
            -a 将目前新增的history指令新增到histfiles中，如果没有加histfiles，则预设写入~/.bash_history
            -r 将histfiles的内容读到目前shell的history记忆中
            -w 将目前history内容写入histfiles中
        正常情况下，历史命令的读取与记录
            当以bash登陆Linux主机后，系统会主动的通过主目录~/bash_history读取曾经执行的指令
            注销时，会将最新的HISTFILESIZE笔指令记录到记录文件中
            也可以用history -w强制立刻写入
                !n          执行第n个指令
                !command    由最近的指令向前搜索开头为command的指令，并执行
                !!          执行上一个指令
        同一账号同时多次登录的history写入问题
            多个bash窗口，只有最后注销的bash才是最后写入的数据，其他bash的指令不会被记录。
            可以用单一bash登录，再用工作控制来切换不同的工作
        无法记录时间
            历史指令无法记录指令下达的时间，可以通过~/.bash_logout来进行history的记录，并加上date来增加时间参数

### 10.4 Bash Shell的操作环境

    登录主机时，会有说明文字，介绍版本等。
    路径与指令搜索顺序
        指令运行的顺序
            以相对/绝对路径执行指令
            由alias找到该指令来执行
            由bash内建的builtin指令来执行
            通过$PATH这个变量的顺序搜索到的第一个指令来执行
        可以通过type -a command来得到搜索顺序
    bash的进站与欢迎信息:/etc/issue,/etc/motd
        进站提示字符文件，/etc/issue，各代码意义
            \d 本地端时间和日期
            \l 显示第几个终端机接口
            \m 显示硬件的等级
            \n 显示主机的网络名称
            \O 显示domain name
            \r 操作系统的版本
            \t 显示本地端时间
            \S 操作系统的名称
            \v 操作系统的版本
        例如\S (terminal: \l) 
            Date: \d \t 
            Kernel \r on an \m 
            Welcome!
        /etc/issue.net，用于telnet远程登陆程序使用。
        如果需要让使用者登录后获得信息，可以将信息加入/etc/motd中。
    bash的环境配置文件
        进入bash就能获得一系列变量，是因为系统有一些环境配置文件，让bash在启动时直接读取这些配置文件，以规划bash的操作环境。这些配置文件可以分为全体系统的配置文件以及用户个人偏好配置文件。如果需要保留对指令别名、自定义的变量，需要写入配置文件
        login和non-login shell
            login shell：取得bash时需要完整的登录流程的，称为login shell。例如，通过tty1-tty6登录，需要输入用户的账号与密码
            non-login shell：取得bash接口的方法不需要重复登录的操作。例如在bash环境下再次下达bash，也不需要登录
            两种取得bash的情况，读取的配置文件数据并不一样。login shell会读取
                /etc/profile，为系统整体的设定，建议不修改
                ~/.bash_profile、~/bash_login、~/.profile，属于用户个人设定
        /etc/profile(login shell读取)
            该配置文件利用使用者的标识符(UID)来决定很多重要的变量数据，也是使用者登入取得bash时一定会读取的配置文件。该文件主要设定的变量
                PATH:根据UID决定PATH变量是否需要含有sbin的系统指令目录
                MAIL:根据账号设定用户的mailbox到/var/spool/mail/账号名
                USER:根据用户的账号设定该变量内容
                HOSTNAME:根据主机的hostname指令决定此变量内容
                HISTSIZE:历史指令记录笔数
                umask:包括root默认为022而一般用户为002
            /etc/profile还会呼叫外部的设定数据
                /etc/profile.d/*.sh
                    该目录下的.sh，如果用户具有r的权限，该文件就会被/etc/profile呼叫进来。该目录文件规范了bash操作接口的颜色、语系、ll与ls指令的指令别名等。如果需要让所有使用者设定一些共享的指令别名时，可用在该目录下自行建立扩展名为.sh的文件，并将所需要的数据写入
                /etc/locale.conf
                    该文件由/etc/profile.d/lang.sh呼叫进来。决定bash预设使用语系种类。文件中最重要的即为LANG/LC_ALL的设定
                /usr/share/bash-completion/completions/*
                    指令补齐、文件名补齐、指令的选项/参数补齐，需要从该目录中找到对应的指令来处理。该目录下的内容由/etc/profile.d/bash_comlpletion.sh这个文件载入
        ~/.bash_profile(login shell读取)
            bash在读完整体环境设定的/etc/profile并借此呼叫其他配置文件后，会读取用户的个人配置文件。login shell的bash环境中，个人偏好配置文件主要有三个
                ~/.bash_profile、~/.bash_login、~/.profile
            但bash的login shell设定只会读取上面文件的其中一个，而读取的顺序是依照上面的顺序。而多种文件，应该是其他shell转换过来的用户的习惯。
            bash配置文件的读入方式是通过指令source来读取的。
        source:读入环境配置文件的指令
            /etc/profile和~/.bash_profile都是在取得login shell的时候才会读取配置文件，所以一般是注销后再登录设定才会生效，但是也可以通过source实现
                source 配置文件名
            利用source或小数点.都可以将配置文件的内容都进来目前的shell环境中。
            如果使用不同配置环境，可以方便地进行切换
        ~/.bashrc(non-login shell读取)
            系统会主动呼叫/etc/bash.bashrc，从而定义
                根据不同UID规范处umask的值
                根据不同UID规范出提示字符(PS1)
                呼叫/etc/profile.d/*.sh的设定
            /etc/skel/.bashrc有~/.bashrc的备份
        其他相关配置文件
            /etc/man_db.conf
                对于管理员来说，该文件的内容规范了使用man时，man page的路径查找位置。
                如果是以tarball方式安装数据，man page可能会放在/usr/local/softpackage/man里面，softpackage为套件名称，就需要以手动的方式将路径加到/etc/man_db.conf中
            ~/.bash_history
                每次登录bash后，bash会先读取这个文件，将所有的历史指令读入内存。
            ~/.bash_logout
                该文件记录了注销bash后，在离开前系统所做的操作。读取该文件的内容，在预设的情况下，bash只是清除屏幕的信息。也可以将一些备份或者是其他重要的工作写在文件中。
    终端机的环境设定：stty,set
        可用在tty1-tty6这六个文字接口的终端机环境中登录，并取得一些字符设定的功能。
        目前使用的Linux版本有非常好的用户环境，但是在一些Unix like的机器中，需要进行一些设定，setting tty
            stty [-a] 
                -a 将所有的stty参数
        重要含义
            intr    送出interrupu信号给正在run的程序
            quit    送出quit信号给正在run的程序
            erase   删除最后输入的一串字符
            kill    删除目前指令行上的所有字符
            eof     结束输入
            start   在某个程序停止后，重新启动output
            stop    停止目前屏幕的输出
            susp    送出terminal stop的信号给正在run的程序
        修改stty：stty function key
        bash还有一些终端机设定值，利用set来设定
            set [-uvCHhmBx]
                -u 预设不启用。若启用后，当使用未设定变量时，显示错误信息
                -v 预设不启用。若启用后，在信息被输出前，先显示信息的原始内容
                -x 预设不启用。若启用后，在指令被执行前，会显示指令内容(前面有++符号)
                -h 预设启用，与历史指令有关
                -H 预设启用，与历史指令有关
                -m 预设启用，与工作管理有关
                -B 预设启用，与括号[]的作用有关
                -C 预设不启用。若使用>等，则若文件存在时，该文件不会被覆盖
            echo $-，显示目前所有的set设定值
            set [+uvCHhmBx]，取消启用参数
        还有其他按键设定，在/etc/inputrc中。还有/etc/DIR_COLOR*和/usr/share/terminfo/*，也是与终端机有关的环境配置文件。bash默认的组合键
            ^C  终止目前的指令
            ^D  输入结束
            ^M  Enter
            ^S  暂停屏幕输出
            ^Q  恢复屏幕输出
            ^U  在提示字符下，将整列指令删除
            ^Z  暂停目前命令
    通配符与特殊符号
        常用通配符
            *   0到多个任意字符
            ?   1个字符
            []  一个[]内的字符
            [-] 在编码顺序内的所有字符
            [^] 表示反向选择，不包含[]内的字符
        bash环境的特殊符号
            #   批注符号
            \   转义符号，将特殊字符或通配符还原成一般字符
            |   pipe，分隔两个pipe指令的界定
            ;   连续指令下达分隔符，连续性指令的界定
            ~   用户的主目录
            $   取用变量前导符，也是变量之前需要加的变量取代值
            &   工作控制，将指令变为后台工作
            !   逻辑运算的非
            /   目录符号，路径分隔的符号
            >,>>数据流重定向，输出导向，分别为取代和累加
            <,<<数据流重定向，输入导向
            ''  单引号，不具有变量置换的功能，$为纯文本
            ""  具有变量置换的功能
            ``  中间为可以先执行的指令，也可用$()
            ()  中间为子shell的起始与结束
            {}  中间为命令区块的组合

### 10.5 数据流重定向

    数据流重定向是将某个指令执行后应该要显示在终端的数据，传输到其他位置。
    数据流重定向介绍
        如果执行一个指令，数据传输情况
            file-STDIN(Standard input,<,<<)->command-STDOUT(>,>>)->screen file/device
                                                    -STDERR(Standard error output,2>,2>>)screen file/device
        standard output和standard error output
            标准输出指的是指令执行所回传的正确的信息，标准错误输出为指令执行失败后，回传的错误信息。
            数据流重定向可以将stdout和stderr分别传送到不同的文件或装置，传送所用的特殊字符
                stdin:  代码0，<,<<
                stdout  代码1，>,>>(1>,1>>)
                stderr  代码2，2>,2>>
            文件建立方式
                文件若不存在，系统会自动建立
                但是文件存在时，系统会先将文件内容清空，然后再将数据写入>
                而>>能够将数据累加
            同时使用stdout和stderr能够分别将正确和错误信息写入文件内
        垃圾桶黑洞设备与特殊写法
            将错误信息忽略掉而不显示和存储，输入到/dev/null
            但是stdout和stderr不能指向同一个文件，因为数据可能交叉写入文件，造成次序错乱。正确写法
                > file 2>&1
                &> file
        standard input:<与<<
            cat > newfile，能够将输入内容写入新文件，需要ctrl+d结束
            cat > newfile < oldfile，类似于cp
            cat > newfile << endword，代表结束的输入字符，输入endword后结束
            使用指令输出重定向
                屏幕输出信息很重要，并且需要保存下来
                背景执行中的程序，不希望干扰屏幕正常的输出结果
                系统的例行指令的(例如/etc/crontab)的执行结果，希望保存
                执行指令的可能已知错误信息，以2> /dev/null丢掉
                错误信息与正确信息需要分别输出时
    指令执行的判断依据：;,&&,||
        一次性执行多次指令
        cmd;cmd(不考虑指令相关性的连续指令下达)
        $?(指令回传值)与&&或||
            如果指令间具有依赖性，而主要判断在于前一个指令结果是否正确。若前一个指令执行的结果为正确，在Linu底下会回传一个$?=0的值
                cmd1&&cmd2  1.若cmd1执行完毕且正确执行($?=0)，开始执行cmd2，否则不执行
                cmd1||cmd2  1.若cmd执行完毕且正确执行($?=0)，则cmd2不执行，否则执行
            可以用于目录存在时才进行新建文件等操作
            Linux下的指令从左往右执行

### 10.6 pipe

    pipe指令使用的是|，与连续下达命令不同
        ls -al /etc | less
    pipe|仅能处理前一个指令传来的正确信息STDOUT，对于STDERR并没有直接处理的能力，即忽略，但是可以通过数据流重定向来接收STDERR。
    pipe第一个为指令，并且必须能够接收STDIN。
    截取指令:cut,grep
        对数据进行分析，一般是按行进行的
        cut
            cut能够将信息的某一段切出来
                cut -d '分隔字符' -f fields，用于特定分隔字符
                cut -c 字符区间，用于排列整齐的信息
                    -d 接分隔字符，与-f一起使用
                    -f 根据-d的分隔字符将一段信息分为多端，-f表示取出第几段
                    -c 以字符单位取出固定的字符区间
            cut -c 12-，能够将每一行的前12个字符去掉
            last输出账号、终端机、来源、时间数据
            但是cut不能处理多个连续字符，例如连续空格，可以使用awk替代
        grep
            grep将需要信息所在行显示
                grep [-acinv] [--color==auto] 'string' filename
                    -a 将二进制文件以文本文件的方式搜索
                    -c 计算找打字符串的次数
                    -i 忽略大小写的不同
                    -n 输出行号
                    -v 反向选择，显示出没有字符串的所在行
                    --color=auto 将找到的关键词部分加上颜色，预设
    排序指令:sort,wc,uniq
        排序可以用于计算数据中相同形态的数据总数
        sort
            排序的字符与语系的编码有关，可以通过LANG=C进行语系统一
                sort [-fbMnrtuk] [file or stdin]
                    -f 忽略大小写
                    -b 忽略最前面的空格符
                    -M 以月份的名字排序，如JAN,DEC
                    -n 使用纯数字进行排序，默认按照文本排序
                    -r 反向排序
                    -u uniq，相同的数据中，仅出现一行代表
                    -t 分隔符，预设用tab
                    -k 用区间进行排序
        uniq
            将重复的数据仅列出一个显示
                uniq [-ic]
                    -i 忽略大小写的不同
                    -c 进行计数
            用来将重复的行删除到一个
        wc
            计算输出信息的统计数据
                wc [-lwm]
                    -l 仅列出行
                    -w 仅列出英文单字数
                    -m 仅列出字符数
    双向重定向:tee
        tee能够同时将数据流分送到文件与屏幕，而输出到屏幕的，为stdout
            tee [-a] file
                -a 以累加的方式，将数据加入file中
    字符转换命令:tc,col,join,paste,expand
        结合字符转换命令在pipe中使用
        tr
            可以用来删除一段信息中的文字，或者进行文字信息替换
                tr [-ds] SET1 ...
                    -d 删除信息中的SET1这个字符串
                    -s 删除连续重复的字符到一个
            例如，tr '[a-z]' '[A-Z]'，替换为大写
            该指令也能写在正则表示法中。除了使用dos2unix，也能够通过将^M转化为\r。
        col
            col [-xb]
                -x 将tab键转换为对应的空格键，便于阅读
            col也有其他特殊的用途
        join
            处理两个文件之间的数据。两个文件当中，有相同数据的一行，才相加。
                join [-ti12] file1 file2
                    -t 接分隔字符。join默认以空格符分隔数据，并且比对第一个字段的数据，如果两个文件相同，则将两笔数据连成一行，且第一个字段放在第一个
                    -i 忽略大小写
                    -1 代表第一个文件要用所接字段分析
                    -2 代表第二个文件要用所接字段分析
            一些文件之间数据具有相关性，例如/etc/passwd、/etc/shadow账号具有相关性，/etc/passwd、/etc/group的GID具有相关性
            在使用join之前，所需要处理的文件需要先经过排序处理，否则可能导致比对项错位、跳过
        paste
            paste仅仅简单讲两个文件的对应行相接，中间以tab隔开
                paste [-d] file1 file2
                    -d 可以接分隔字符，预设以tab来分隔
                    -  file部分写成-，表示来自standard input
        expand
            将tab转为空格
                expand [-t] file
                    -t 接数字，一般情况tab用8个空格键取代，可以自定义。
                unexpand能够键空格转为tab
    分区指令:split
        如果有文件过大，导致一些便携式设备无法复制，可以使用split，将一个大文件，根据文件大小或行数进行分区
            split [-bl] file PREFIX
                -b 接要分区成的文件大小，可加单位，如b,k,m
                -l 以行数进行分区
                PREFIX 表示前导符，可作为分区文件的前导名称
        合并可以使用，cat services* >> servicesback
        能够方便将文件分区为软件支持的最大容量，如gmail单一信件25M
    参数代换:xargs
        产生某个指令的参数，xargs可以读入stdin的数据，并以空格符或断行符作为分辨，将stdin的数据分割成arguments。
            xargs [-Oepn] command
                -O 如果输入的stdin含有特殊字符，例如`,\,空格等，-O会将其还原为一般字符
                -e EOF，接字符串，当xargs分析到这个字符串时，就会停止工作
                -p 在执行每个指令的argument时，会询问使用者
                -n 接次数，每次command指令执行时使用的参数个数
        xargs不接任何指令时，以echo输出
        id列出账号内容，id并非pipe指令，不能接收stdin，而且只能接收一个参数
            cut -d ':' -f 1 /etc/passwd | head -n 3 | xargs -n 1 id 
    减号-的用法
        某些指令需要用到文件名来进行处理时，stdin和stdout可以用-来替代
            tar -cvf - /home | tar -xvf - -C /tmp/homebac

## 十一、正则表达式与文件格式化处理

    正则表达式，也成为常规表示法，通过一些特殊字符的排列，用以查找、替换、删除一行或多行字符串。

### 11.1 介绍

    正则表达式是处理字符串的方法，以行为单位来进行字符串的处理行为，正则表达式通过一些特殊符号的辅助，可以让使用者达到查找、删除、替换特定字符串的处理程序
    正则表达式是一种表示法，只要工具程序支持这种表示法，该工具程序就可以用来作为正则表达式的字符串处理。
    延伸的正则表达式，正则表达式的字符串表示方式依照不同的严谨程度分为基础正则表达式和延伸正则表达式
    正则表达式和通配符完全不同

### 11.2 基础正则表达式

    对字符排序有影响的语系数据会对正则表达式有影响。
    语系对正则表达式的影响
        LANG=C 编码顺序，0-9A-Za-z
        LANG=zh_TW 0-9aA-zZ
        所以[A-Z]的结果可能不同。一般使用兼容于POSIX的标准，使用C这个语系。
            特殊符号    代表意义
            [:alnum:]   英文大小写字符及数字，0-9a-zA-Z
            [:alpha:]   英文大小写字符
            [:blank:]   空格键与tab
            [:cntrl:]   控制按键，包括CR、LF、Tab、Del等
            [:digit:]   数字
            [:graph:]   除空格符(空格键与tab)的所有按键
            [:lower:]   小写字符
            [:print:]   可打印字符
            [:punct:]   标点符号，"'?!;:#$...
            [:upper:]   大写字符
            [:space:]   产生空白的字符，包括空格键、Tab、CR等
            [:xdigit:]  16进制的数字类型，0-9，A-F，a-f
    grep的一些进阶选项
        grep [-A] [-B] [--color=auto] '搜索字符串' filename
            -A 接数字，同时列出后续n行
            -B 接数字，同时列出前面n行
            --color=auto 默认，将正确的字符串内容显示特殊颜色
        dmesg列出核心信息，包括硬件检测的流程
        同样grep也是以行为单位进行处理
    基础正规表示法练习
        搜索特定字符串
            grep -n 'str' file
            grep -vn 'str' file，显示不含特定字符串行
        搜索集合字符
            grep -n '[...]' file
        [:lower:]等价于a-z，所以[[:lower:]]=[a-z]
        ^[]表示位于行首，[]$表示位于行尾，因为linux是$作为行结尾。^$可以寻找空行
        .表示任意一个字符，*表示任意个前一个字符，.*一起表示任意多个任意字符
        限定连续RE字符范围{}
            因为{}在shell有特殊意义，所以需要转义
                grep '\{n\}
    基础正则表达式字符
        ^word   待搜索的字符串在行首
        word$   待搜索的字符串在行尾
        .       任意一个字符
        \       转义字符，将特殊符号转义为普通符号
        *       任意个前一个字符
        [list]  字符集合的RE字符，列出要截取的字符
        [n1-n2] 字符集合的RE字符，列出要截取的字符范围
        [^lsit] 字符集合的RE字符，列出排除的字符串或范围
        \{n,m\} 连续n到m个前一个RE字符，二者之一可以省略，表示0-m或n-∞
    sed工具
        sed也是一个pipe指令，将数据进行替换、删除、新增、截取特定行等。
            sed [-nefr] [操作]
                -n 安静模式，一般sed会将来自STDIN的内容输出。
                -e 直接在指令行模式上进行sed的操作编辑
                -f 直接sed的操作写在文件中，接含有执行操作的文件
                -r sed的操作支持的是延伸型正则表达式的语法(预设是基础)
                -i 直接修改读取的文件内容，而不是输出
                操作 [n1[,n2]]function
                    n1,n2 不一定存在，一般代表进行操作的行数
                    function
                        a 新增，接字符串，下一行出现
                        c 替换，接字符串，替代n1,n2之间的行
                        d 删除
                        i 插入，接字符串，上一行出现
                        p 打印，将某个选择的内容输出，与sed -n一起
                        s 替换，直接进行替换，可以搭配正则表达式
        以行为单位的新增/删除功能
            sed '2,5d'，可用$表示最后一行
        替换和输出
            sed '2,5c No 2-5 number'，c和替换的内容间的空格不会被使用
            sed -n '5,7p'
        部分内容的搜索和替换
            sed 's/oldstr/newstr/g'
            ifconfig获取网络数据
            ifconfig eth0 | grep 'inet ' | sed 's/^.*inet //g' | sed 's/ *netmask.*$//g'
        直接修改文件内容
            sed -i '$str' file，行尾追加

### 11.3 延伸正则表达式

    grep -E或egrep使用延伸型，支持群组功能|，进行多种操作
        RE字符  意义
        +       重复一个及以上的前一个字符
        ?       不大于一个的前一个字符
        |       用或的方式找出多个字符串
        ()      找出群组字符串
        ()+     多个重复群组的判别
    !在正则表达式中并不是特殊字符

### 11.4 文件的格式化与相关处理

    不需要编辑，通过数据流重定向和printf即可
    格式化打印:printf
        printf 'format' content
            特殊格式
                \a 警告声音输出
                \b 退格键
                \f 消除屏幕(form feed)
                \r Enter
                \t 水平tab
                \v 垂直tab
                \xNN NN为两位数的数字，将数字转换为字符
            C语言程序常见变量格式
                %ns n个字符
                %ni n位数字
                %N.nf 浮点数，N为总位数(包含小数点)，n为小数点位数
            printf '%s\t %s\t %s\t %s\t %s\t \n' $(cat txt)
        还可以输出ASCII字符
    awk:数据处理工具
        awk倾向于将一行当中分成多个字段来处理。
            awk '条件类型1{操作1} 条件类型2{操作2} ...' filename
        awk可以处理后续接的文件，也可以读取STDIN。awk主要处理每一行的字段内的数据，默认的字段分隔符为空格键或tab键。
            awk '{print $1 "\t" $3}' file，输出每一行第一、三个字段
        每一行的每个字段有变量名称，$1,$2,...。
        整个akw的处理流程
            读入第一行，并将第一行的内容填入$1,$2,...等变量中
            根据条件类型的限制，判断是否需要进行操作
            完成所有的操作和条件类型
            对后续行重复以上步骤
        内建变量
            NF 每一行($0)的字段总数
            NR 目前awk处理的行号
            FS 目前的分隔字符，默认为空格键，赋值{FS="分隔符"}
        非变量的文字部分，需要用双引号定义
        awk的逻辑运算字符
            >   大于
            <   小于
            >=  大于或等于
            <=  小于或等于
            ==  等于
            !=  不等于
            =   不是逻辑运算符，进行变量的赋值
        逻辑判定成功的结果为1
        赋值成功后在下一行生效，可以使用关键词BEGIN进行预先设定，'BEGIN {FS=":"} ...'
        print单纯输出，printf能够进行格式化输出
            在一个{}中，如果进行多个操作，只能一行输入一个操作，或者使用分号隔开
            格式化输出时，printf的格式设定中，需要加上\n，才能换行
            与bash shell的变量不同，awk中变量可以直接使用
        {}中支持if，所以可以把条件判断移入。
        awk还能够进行循环计算
    文件比对工具
        同一个软件包的不同版本之间，比较配置文件与原始文件的差异。
        diff
            以行为单位来比对。一般用在ASCII纯文本文件的比对上。通常用在同一个文件(软件)的新旧版本差异
                diff [-bBi] oldfile newfile
                    file可以用-替换
                    -b 忽略一行当中，空格符的差异
                    -B 忽略空白行的差异
                    -i 忽略大小写
                输出得到差异行，并用符号表示差异类型
            能够比较目录差异
        cmp
            利用字节单位进行比较，能够比较二进制文件
                cmp [-l] file1 file2
                    -l 将所有不同的字节列出来，预设只列出第一个
        patch
            比较旧版本的差异，将差异文件制作成补丁文件，再由补丁文件更新旧文件
            diff -Naur oldfile newfile > file.patch
                新旧文件的信息---为旧文件，+++为新文件
                修改数据的范围，@@ -1,10 +1,9 @@，表明新旧文件的修改范围
                然后给出修改内容
            diff输出的比较文件一般用.patch文件。
                patch -pN < patch_file
                patch -R -pN < patch_file
                    -p 接取消目录层数
                    -R 还原，将新的文件还原为旧版本
    文件打印准备:pr
        可以用pr加入标题、页码等

## 十二、Shell scripts

### 12.1 介绍

    程序化脚本，利用shell的功能所写的一个程序，该程序用纯文本文件，将一些shell的语法与指令(含外部指令)写在里面，搭配正则表达式、pipe和数据流重定向等，达到处理目的。
    作用
        自动化管理
        追踪与管理系统的重要工作
            /etc/init.d/*利用shell进行系统服务启动，开机(booting)过程也是利用shell
        简单入侵检测
        连续指令单一化
            汇整一些在命令行下达的连续指令
        简单的数据处理
        shell script在系统管理方面好用，但是在大量数值运算上较慢，占用CPU资源多。
    撰写与执行
        注意事项
            指令的执行是从上而下、从左到右的分析与执行
            指令选项参数间的多个空白会被忽略掉
            空白行也会被忽略，tab视为空格键
            读到一个Enter符号(CR)，就尝试开始执行
            可以使用转移符号\Enter来延伸多行
            #作为批注
        直接执行下达，shell.sh文件必须要具备可读与可执行rx的权限
            绝对路径、相对路径、PATH都能够执行
        bash程序执行:bash *.sh或sh *.sh，/bin/sh为/bin/bash的链接文件，只需要文件有r权限
        因为指令搜索顺序，工作目录下的指令执行一般用./*.sh
        撰写script
            #!/bin/bash，声明使用的shell名称，当程序被执行时，能够加载bash的相关环境配置文件(一般是non-login shell的~/.bashrc)，并且执行bash来使之后的指令能够执行
            除了#!声明shell名称，#用于注释，建议内容：内容与功能、版本信息、作者与联系方式、建立日期、历史记录等
            PATH=$PATH:~/bin，主要环境变量的声明，PATH和LANG，能够直接下达外部指令
            export PATH
            echo -e "Hello world! \a \n"
            exit 0，执行结果，定义回传值
            chmod a+x *.sh; ./*.sh来执行
    撰写shell script的建议
        除了上述注释内容外，还需要
            特殊的指令，通过绝对路径下达，执行前需要的环境变量的定义
        注意代码排版

### 12.2 简单的shell script

    交互式脚本：变量内容由用户设定
    随日期变化：利用date进行文件的建立
        date1=$(date --date='2 days ago' +%Y%m%d)  # 前两天的日期 
        date2=$(date --date='1 days ago' +%Y%m%d)  # 前一天的日期 
        date3=$(date +%Y%m%d)                      # 今天的日期
    数值运算：简单的加减乘除
        var=$((运算内容))
        declare -i(type) var=运算内容
        如果需要进行小数运算，可以调用bc，也支持pipe
            scale=n;4*a(1)，为bc提供的计算pi的函数
            echo "scale=${num}; 4*a(1)" | bc -lq 
            可以用于测试虚拟机的效率
    script的执行方式差异(source,sh script,./script)
        不同的script执行方式结果不一样
        直接执行
            使用绝对路径、相对路径、${PATH}、bash/sh，script都会使用一个新的bash环境来执行脚本内的指令，即子程序。当子程序完成后，在子程序内的各项变量或动作将会结束而不会传回到父程序中
        利用source来执行：在父程序中执行
            可以用source来使配置文件生效

### 12.3 判断式

    利用test指令的测试功能
        test通过回传值给出判断结果，利用$?、&&和||实现条件执行
            测试标志    意义
            关于文件类型判断test -[] file
            -e          文件是否存在
            -f          文件是否存在且为文件
            -d          文件是否存在且为目录
            -b          文件是否存在且为block device
            -c          文件是否存在且为character device
            -S          文件是否存在且为Socket
            -p          文件是否存在且为FIFO(pipe)
            -L          文件是否存在且为链接文件
            关于文件的权限判断
            -r          文件是否存在且可读
            -w          文件是否存在且可写
            -x          文件是否存在且可执行
            -u          文件是否存在且有SUID
            -g          文件是否存在且有SGID
            -k          文件是否存在且有Sticky bits
            -s          文件是否存在且为非空白文件
            两个文件之间的比较test file1 -[] file2
            -nt         (newer than)file1是否比file2新
            -ot         (older than)file1是否比file2旧
            -ef         判断file1和file2是否为同一文件，可以用在判断hard link
            两个整数之间的判定test n1 -[] n2
            -eq         两数值相等
            -ne         两数值不等
            -gt         n1大于n2
            -lt         n1小于n2
            -ge         n1大于等于n2
            -le         n1小于等于n2
            判定字符串的数据
            test -z string  判定字符串是否为0
            test -n string  判定字符串是否不为0
            test str1 == str2   判定str1是否等于str2
            test str1 == str2   判定str1是否不等于str2
            多重条件判定test -r file -a -x file
            -a 两情况同时成立
            -o 两情况任意一个成立
            !  反相状态
        root在很多权限的限制上都是无效的，所以root执行和ll得到的结果不一定相同
    利用判断符号[]
        [ -z "${HOME}" ] ; echo $?
        在bash的语法中使用中括号作为shell的判断式时，中括号的内侧需要有空格符号来分隔。=与==作用相同
            []内的每个组件都需要有空格键来分隔
            []内的变量，最好用双引号括起来
            []内的常数，最好用单或双引号括起来
            中括号的使用方法基本一致，同时中括号常用在条件判断式if...then...fi的情况中
    shell script的默认变量($0,$1,$2...)
        /etc/init.d/newword restart能够重启系统网络,stop关闭该服务
        script针对参数设定好一些变量名称
            /path/to/scriptname opt1    opt2    opt3    opt4
            $0                  $1      $2      $3      $4
            $#  所接的参数个数
            $@  "$1" "$2" "$3" "$4" ...，每个变量独立
            $*  "$1c$2c$3c$4"，c为分隔字符，默认为空格键
        shift:造成参数变量号码偏移
            shift n能够将输入的变量前移n个，便于循环处理

### 12.4 条件判断式

    利用if...then
        单层、简单条件判断式
            if [ 条件判断式 ] ; then
                条件判断成立执行
            fi
            [ 条件1 -o 条件2 ]可以替换为[ 条件1 ] || [ 条件2 ]
        多重、复杂条件判断式
            if [ 条件判断式 ] ; then
                条件判断成立执行
            else
                条件判断不成立执行
            fi
            if [ 条件判断式1 ] ; then
                条件判断1成立执行
            elif [ 条件判断式2 ] ; then
                条件判断1不成立、条件判断2成立执行
            else
                条件判断1、2不成立执行
            fi
            netstat -tuln能够取得目前主机有启动的服务
            常见端口与相关网络服务的关系
                80:WWW  22:ssh  21:ftp  25:mail 111:RPC 631:CUPS
    利用case...esac判断
        对于多个分支，使用case...in...esac
            case $variable in
                "第一个变量内容")   变量内容建议用""括起来
                    程序段
                    ;;              每个类别结尾使用连续的;;来处理
                "第二个程序内容")
                    程序段
                    ;;
                *)  最后一个变量内容用*来代表所有其他值
                ...
                除开前面变量内容的其他程序段
        早期系统的很多服务的启动scripts使用case...esac的写法
            /etc/init.d/netconsole restart即是如此
        一般情况下，$variable可以通过直接下达和交互式获得
    利用function功能
        function语法
            [function] fname[()]{       function和()只能省略一个
                程序段
            }
        shell script的执行方式是由上到下，从左到右，因此在shell script中的function的设定要在被调用的位置前面。调用时用函数名即可，不需要加括号
        function也具有内建变量，与shell script类似，函数名称$0，后续变量也是以$1,$2...来取代的。当n大于9时，不能用$n而是${n}

### 12.5 循环loop

    循环可以不断执行程序段，直到用户设定的条件达到
    while do done,until do done(不定循环)
        条件成立进行循环
            while [ condition ]
            do
                程序段落
            done
        条件成立终止循环
            until [ condition ]
            do
                程序段落
            done
    for...do...done(固定循环)
        for var in con1 con2 con3 ...
        do
            程序段
        done
        每次循环的变量内容依次为con1 con2 con3...
        可以使用cut获取类似列表内容，$(seq n1 n2)或者{n1..n2}(bash的内建机制)获得1-100的整数
    for...do.done的数值处理
        for (( 初始值;限制值;步进 ))    例如 i=1; i<=${nu}; i=i
        do
            程序段
        done
        这种语法适用于数值方式的运算，初始值为某个变量在循环内的起始值，限制值为判断条件，步进为每次循环变量的变化量
    搭配随机数与数组
        $RANDOM获取0-32767的随机整数

### 12.6 shell script的追踪与debug

    scripts在执行前可以不通过执行来判断是否有问题
    sh [-nvx] *.sh
        -n 不执行，只查询语法
        -v 在执行前，先将脚本的内容输出
        -x 将使用到的脚本内容输出
            +后为指令串，可以判断程序代码的位置
